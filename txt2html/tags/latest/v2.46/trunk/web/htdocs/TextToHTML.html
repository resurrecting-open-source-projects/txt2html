<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>HTML::TextToHTML - convert plain text file to HTML.</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:Gentoo@mithril.katspace.homelinux.org" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#version">VERSION</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#history">History</a></li>
	</ul>

	<li><a href="#requires">REQUIRES</a></li>
	<li><a href="#installation">INSTALLATION</a></li>
	<li><a href="#options">OPTIONS</a></li>
	<li><a href="#methods">METHODS</a></li>
	<ul>

		<li><a href="#new">new</a></li>
		<li><a href="#args">args</a></li>
		<li><a href="#process_chunk">process_chunk</a></li>
		<li><a href="#process_para">process_para</a></li>
		<li><a href="#txt2html">txt2html</a></li>
	</ul>

	<li><a href="#private_methods">PRIVATE METHODS</a></li>
	<ul>

		<li><a href="#init_our_data">init_our_data</a></li>
		<li><a href="#deal_with_options">deal_with_options</a></li>
		<li><a href="#escape">escape</a></li>
		<li><a href="#demoronize_char">demoronize_char</a></li>
		<li><a href="#demoronize_code">demoronize_code</a></li>
		<li><a href="#get_tag">get_tag</a></li>
		<li><a href="#close_tag">close_tag</a></li>
		<li><a href="#hrule">hrule</a></li>
		<li><a href="#shortline">shortline</a></li>
		<li><a href="#is_mailheader">is_mailheader</a></li>
		<li><a href="#mailheader">mailheader</a></li>
		<li><a href="#mailquote">mailquote</a></li>
		<li><a href="#subtract_modes">subtract_modes</a></li>
		<li><a href="#paragraph">paragraph</a></li>
		<li><a href="#listprefix">listprefix</a></li>
		<li><a href="#startlist">startlist</a></li>
		<li><a href="#endlist">endlist</a></li>
		<li><a href="#continuelist">continuelist</a></li>
		<li><a href="#liststuff">liststuff</a></li>
		<li><a href="#get_table_type">get_table_type</a></li>
		<li><a href="#is_aligned_table">is_aligned_table</a></li>
		<li><a href="#is_pgsql_table">is_pgsql_table</a></li>
		<li><a href="#is_border_table">is_border_table</a></li>
		<li><a href="#is_delim_table">is_delim_table</a></li>
		<li><a href="#tablestuff">tablestuff</a></li>
		<li><a href="#make_aligned_table">make_aligned_table</a></li>
		<li><a href="#make_pgsql_table">make_pgsql_table</a></li>
		<li><a href="#make_border_table">make_border_table</a></li>
		<li><a href="#make_delim_table">make_delim_table</a></li>
		<li><a href="#is_preformatted">is_preformatted</a></li>
		<li><a href="#split_end_explicit_preformat">split_end_explicit_preformat</a></li>
		<li><a href="#endpreformat">endpreformat</a></li>
		<li><a href="#preformat">preformat</a></li>
		<li><a href="#make_new_anchor">make_new_anchor</a></li>
		<li><a href="#anchor_mail">anchor_mail</a></li>
		<li><a href="#anchor_heading">anchor_heading</a></li>
		<li><a href="#heading_level">heading_level</a></li>
		<li><a href="#is_ul_list_line">is_ul_list_line</a></li>
		<li><a href="#is_heading">is_heading</a></li>
		<li><a href="#heading">heading</a></li>
		<li><a href="#is_custom_heading">is_custom_heading</a></li>
		<li><a href="#custom_heading">custom_heading</a></li>
		<li><a href="#unhyphenate_para">unhyphenate_para</a></li>
		<li><a href="#tagline">tagline</a></li>
		<li><a href="#iscaps">iscaps</a></li>
		<li><a href="#caps">caps</a></li>
		<li><a href="#do_delim">do_delim</a></li>
		<li><a href="#glob2regexp">glob2regexp</a></li>
		<li><a href="#add_regexp_to_links_table">add_regexp_to_links_table</a></li>
		<li><a href="#add_literal_to_links_table">add_literal_to_links_table</a></li>
		<li><a href="#add_glob_to_links_table">add_glob_to_links_table</a></li>
		<li><a href="#parse_dict">parse_dict</a></li>
		<li><a href="#setup_dict_checking">setup_dict_checking</a></li>
		<li><a href="#in_link_context">in_link_context</a></li>
		<li><a href="#apply_links">apply_links</a></li>
		<li><a href="#check_dictionary_links">check_dictionary_links</a></li>
		<li><a href="#load_dictionary_links">load_dictionary_links</a></li>
		<li><a href="#do_file_start">do_file_start</a></li>
		<li><a href="#do_init_call">do_init_call</a></li>
	</ul>

	<li><a href="#file_formats">FILE FORMATS</a></li>
	<ul>

		<li><a href="#link_dictionary">Link Dictionary</a></li>
		<li><a href="#input_file_format">Input File Format</a></li>
	</ul>

	<li><a href="#examples">EXAMPLES</a></li>
	<ul>

		<li><a href="#add_further_arguments">Add further arguments</a></li>
		<li><a href="#convert_a_file">Convert a file</a></li>
		<li><a href="#make_a_pipleline">Make a pipleline</a></li>
	</ul>

	<li><a href="#notes">NOTES</a></li>
	<li><a href="#bugs">BUGS</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyright_and_licence">COPYRIGHT AND LICENCE</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>HTML::TextToHTML - convert plain text file to HTML.</p>
<p>
</p>
<hr />
<h1><a name="version">VERSION</a></h1>
<p>This describes version <strong>2.46</strong> of HTML::TextToHTML.</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  From the command line:</pre>
<pre>
    txt2html I&lt;arguments&gt;</pre>
<pre>
  From Scripts:</pre>
<pre>
    use HTML::TextToHTML;
 
    # create a new object
    my $conv = new HTML::TextToHTML();</pre>
<pre>
    # convert a file
    $conv-&gt;txt2html(infile=&gt;[$text_file],
                     outfile=&gt;$html_file,
                     title=&gt;&quot;Wonderful Things&quot;,
                     mail=&gt;1,
      ]);</pre>
<pre>
    # reset arguments
    $conv-&gt;args(infile=&gt;[], mail=&gt;0);</pre>
<pre>
    # convert a string
    $newstring = $conv-&gt;process_chunk($mystring)</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>HTML::TextToHTML converts plain text files to HTML. The txt2html script
uses this module to do the same from the command-line.</p>
<p>It supports headings, tables, lists, simple character markup, and
hyperlinking, and is highly customizable. It recognizes some of the
apparent structure of the source document (mostly whitespace and
typographic layout), and attempts to mark that structure explicitly
using HTML. The purpose for this tool is to provide an easier way of
converting existing text documents to HTML format, giving something nicer
than just whapping the text into a big PRE block.</p>
<p>
</p>
<h2><a name="history">History</a></h2>
<p>The original txt2html script was written by Seth Golub (see
<a href="http://www.aigeek.com/txt2html/),">http://www.aigeek.com/txt2html/),</a> and converted to a perl module by
Kathryn Andersen (see <a href="http://www.katspace.com/tools/text_to_html/)">http://www.katspace.com/tools/text_to_html/)</a> and
made into a sourceforge project by Sun Tong (see
<a href="http://sourceforge.net/projects/txt2html/).">http://sourceforge.net/projects/txt2html/).</a>  Earlier versions of the
HTML::TextToHTML module called the included script texthyper so as not
to clash with the original txt2html script, but now the projects have
all been merged.</p>
<p>
</p>
<hr />
<h1><a name="requires">REQUIRES</a></h1>
<p>HTML::TextToHTML requires Perl 5.6.1 or later.</p>
<p>For installation, it needs:</p>
<pre>
    Module::Build</pre>
<p>The txt2html script needs:</p>
<pre>
    Getopt::Long
    Getopt::ArgvFile
    Pod::Usage
    File::Basename</pre>
<p>For testing, it also needs:</p>
<pre>
    Test::More</pre>
<p>For debugging, it also needs:</p>
<pre>
    Data::Dumper</pre>
<p>
</p>
<hr />
<h1><a name="installation">INSTALLATION</a></h1>
<p>Make sure you have the dependencies installed first!
(see REQUIRES above)</p>
<p>Some of those modules come standard with more recent versions of perl,
but I thought I'd mention them anyway, just in case you may not have
them.</p>
<p>If you don't know how to install these, try using the CPAN module, an
easy way of auto-installing modules from the Comprehensive Perl Archive
Network, where the above modules reside.
Do ``perldoc perlmodinstall'' or ``perldoc CPAN'' for more information.</p>
<p>To install this module type the following:</p>
<pre>
   perl Build.PL
   ./Build
   ./Build test
   ./Build install</pre>
<p>Or, if you're on a platform (like DOS or Windows) that doesn't like the
``./'' notation, you can do this:</p>
<pre>
   perl Build.PL
   perl Build
   perl Build test
   perl Build install</pre>
<p>In order to install somewhere other than the default, such as
in a directory under your home directory, like ``/home/fred/perl''
go</p>
<pre>
   perl Build.PL --install_base /home/fred/perl</pre>
<p>as the first step instead.</p>
<p>This will install the files underneath /home/fred/perl.</p>
<p>You will then need to make sure that you alter the PERL5LIB variable to
find the modules, and the PATH variable to find the script.</p>
<p>Therefore you will need to change:
your path, to include /home/fred/perl/script (where the script will be)</p>
<pre>
        PATH=/home/fred/perl/script:${PATH}</pre>
<p>the PERL5LIB variable to add /home/fred/perl/lib</p>
<pre>
        PERL5LIB=/home/fred/perl/lib:${PERL5LIB}</pre>
<p>Note that the system links dictionary will be installed as
``/home/fred/perl/share/txt2html/txt2html.dict''</p>
<p>If you want to install in a temporary install directory (such as
if you are building a package) then instead of going</p>
<pre>
   perl Build install</pre>
<p>go</p>
<pre>
   perl Build install destdir=/my/temp/dir</pre>
<p>and it will be installed there, with a directory structure under
/my/temp/dir the same as it would be if it were installed plain.
Note that this is NOT the same as setting --install_base, because
certain things are done at build-time which use the install_base info.</p>
<p>See ``perldoc perlrun'' for more information on PERL5LIB, and
see ``perldoc Module::Build'' for more information on
installation options.</p>
<p>
</p>
<hr />
<h1><a name="options">OPTIONS</a></h1>
<p>All arguments can be set when the object is created, and further options
can be set when calling the actual txt2html method. Arguments
to methods can take either a hash of arguments, or a reference to an
array.  Note that the reference-to-array method is depricated and is only
retained for backwards compatibility.</p>
<p>Note that all option-names must match exactly -- no abbreviations are
allowed.</p>
<p>The arguments get treated differently depending on whether they are
given in a hash or a reference to an array.  When the arguments are
in a hash, the argument-keys are expected to have values matching
those required for that argument -- whether that be a boolean, a string,
a reference to an array or a reference to a hash.  These will replace
any value for that argument that might have been there before.</p>
<p>When the arguments are in a reference to an array, it is treated
somewhat as if it were a command-line: option names are expected to
start with '--' or '-', boolean options are set to true as soon as the
option is given (no value is expected to follow),  boolean options with
the word ``no'' prepended set the option to false, string options are
expected to have a string value following, and those options which are
internally arrays or hashes are treated as cumulative; that is, the
value following the --option is added to the current set for that
option,  to add more, one just repeats the --option with the next value,
and in order to reset that option to empty, the special value of ``CLEAR''
must be added to the list.</p>
<p>NOTE: the reference-to-an-array usage is DEPRECATED and will be removed
in the future.</p>
<dl>
<dt><strong><a name="item_append_file">append_file</a></strong>

<dd>
<pre>
    append_file=&gt;I&lt;filename&gt;</pre>
</dd>
<dd>
<p>If you want something appended by default, put the filename here.
The appended text will not be processed at all, so make sure it's
plain text or decent HTML.  i.e. do not have things like:
    Mary Andersen &lt;<a href="mailto:kitty@example.com">kitty@example.com</a>&gt;
but instead, have:
    Mary Andersen <a href="mailto:&lt;kitty@example.com&gt;">&lt;kitty@example.com&gt;</a></p>
</dd>
<dd>
<p>(default: nothing)</p>
</dd>
<dt><strong><a name="item_append_head">append_head</a></strong>

<dd>
<pre>
    append_head=&gt;I&lt;filename&gt;</pre>
</dd>
<dd>
<p>If you want something appended to the head by default, put the filename here.
The appended text will not be processed at all, so make sure it's
plain text or decent HTML.  i.e. do not have things like:
    Mary Andersen &lt;<a href="mailto:kitty@example.com">kitty@example.com</a>&gt;
but instead, have:
    Mary Andersen <a href="mailto:&lt;kitty@example.com&gt;">&lt;kitty@example.com&gt;</a></p>
</dd>
<dd>
<p>(default: nothing)</p>
</dd>
<dt><strong><a name="item_body_deco">body_deco</a></strong>

<dd>
<pre>
    body_deco=&gt;I&lt;string&gt;</pre>
</dd>
<dd>
<p>Body decoration string: a string to be added to the BODY tag so that
one can set attributes to the BODY (such as class, style, bgcolor etc)
For example, ``class='withimage'''.</p>
</dd>
<dt><strong><a name="item_bold_delimiter">bold_delimiter</a></strong>

<dd>
<pre>
    bold_delimiter=&gt;I&lt;string&gt;</pre>
</dd>
<dd>
<p>This defines what character (or string) is taken to be the delimiter of
text which is to be interpreted as bold (that is, to be given a STRONG
tag).  If this is empty, then no bolding of text will be done.
(default: #)</p>
</dd>
<dt><strong><a name="item_bullets">bullets</a></strong>

<dd>
<pre>
    bullets=&gt;I&lt;string&gt;</pre>
</dd>
<dd>
<p>This defines what single characters are taken to be ``bullet'' characters
for unordered lists.  Note that because this is used as a character
class, if you use '-' it must come first.
(default:-=o*\267)</p>
</dd>
<dt><strong><a name="item_bullets_ordered">bullets_ordered</a></strong>

<dd>
<pre>
    bullets_ordered=&gt;I&lt;string&gt;</pre>
</dd>
<dd>
<p>This defines what single characters are taken to be ``bullet'' placeholder
characters for ordered lists.  Ordered lists are normally marked by
a number or letter followed by '.' or ')' or ']' or ':'.  If an ordered
bullet is used, then it simply indicates that this is an ordered list,
without giving explicit numbers.</p>
</dd>
<dd>
<p>Note that because this is used as a character class, if you use '-' it
must come first.
(default:nothing)</p>
</dd>
<dt><strong><a name="item_caps_tag">caps_tag</a></strong>

<dd>
<pre>
    caps_tag=&gt;I&lt;tag&gt;</pre>
</dd>
<dd>
<p>Tag to put around all-caps lines
(default: STRONG)
If an empty tag is given, then no tag will be put around all-caps lines.</p>
</dd>
<dt><strong><a name="item_custom_heading_regexp">custom_heading_regexp</a></strong>

<dd>
<pre>
    custom_heading_regexp=&gt;\@custom_headings</pre>
</dd>
<dd>
<p>Add patterns for headings.  Header levels are assigned by regexp in the
order seen in the input text. When a line matches a custom header
regexp, it is tagged as a header.  If it's the first time that
particular regexp has matched, the next available header level is
associated with it and applied to the line.  Any later matches of that
regexp will use the same header level.  Therefore, if you want to match
numbered header lines, you could use something like this:</p>
</dd>
<dd>
<pre>
    my @custom_headings = ('^ *\d+\. \w+',
                           '^ *\d+\.\d+\. \w+',
                           '^ *\d+\.\d+\.\d+\. \w+');</pre>
</dd>
<dd>
<pre>
    ...
        custom_heading_regexp=&gt;\@custom_headings,
    ...</pre>
</dd>
<dd>
<p>Then lines like</p>
</dd>
<dd>
<pre>
                &quot; 1. Examples &quot;
                &quot; 1.1. Things&quot;
            and &quot; 4.2.5. Cold Fusion&quot;</pre>
</dd>
<dd>
<p>Would be marked as H1, H2, and H3 (assuming they were found in that
order, and that no other header styles were encountered).
If you prefer that the first one specified always be H1, the second
always be H2, the third H3, etc, then use the ``explicit_headings''
option.</p>
</dd>
<dd>
<p>This expects a reference to an array of strings.</p>
</dd>
<dd>
<p>(default: none)</p>
</dd>
<dt><strong><a name="item_debug">debug</a></strong>

<dd>
<pre>

    debug=&gt;1</pre>
</dd>
<dd>
<p>Enable copious script debugging output (don't bother, this is for the
developer) (default: false)</p>
</dd>
<dt><strong><a name="item_default_link_dict">default_link_dict</a></strong>

<dd>
<pre>
    default_link_dict=&gt;I&lt;filename&gt;</pre>
</dd>
<dd>
<p>The name of the default ``user'' link dictionary.
(default: ``$ENV{'HOME'}/.txt2html.dict'' -- this is the same as for
the txt2html script.  If there is no $ENV{HOME} then it is just '.txt2html.dict')</p>
</dd>
<dt><strong><a name="item_demoronize">demoronize</a></strong>

<dd>
<pre>
    demoronize=&gt;1</pre>
</dd>
<dd>
<p>Convert Microsoft-generated character codes that are non-ISO codes into
something more reasonable.
(default:true)</p>
</dd>
<dt><strong><a name="item_dict_debug">dict_debug</a></strong>

<dd>
<pre>
    dict_debug=&gt;I&lt;n&gt;</pre>
</dd>
<dd>
<p>Debug mode for link dictionaries Bitwise-Or what you want to see:
          1: The parsing of the dictionary
          2: The code that will make the links
          4: When each rule matches something
          8: When each tag is created</p>
</dd>
<dd>
<p>(default: 0)</p>
</dd>
<dt><strong><a name="item_doctype">doctype</a></strong>

<dd>
<pre>
    doctype=&gt;I&lt;doctype&gt;</pre>
</dd>
<dd>
<p>This gets put in the DOCTYPE field at the top of the document, unless it's
empty.  (default : ``-//W3C//DTD HTML 4.01//EN'' ``http://www.w3.org/TR/html4/strict.dtd'')
If --xhtml is true, the contents of this is ignored, unless it's
empty, in which case no DOCTYPE declaration is output.</p>
</dd>
<dt><strong><a name="item_eight_bit_clean">eight_bit_clean</a></strong>

<dd>
<pre>
    eight_bit_clean=&gt;1</pre>
</dd>
<dd>
<p>If false, convert Latin-1 characters to HTML entities.
If true, this conversion is disabled; also ``demoronize'' is set to
false, since this also changes 8-bit characters.
(default: false)</p>
</dd>
<dt><strong><a name="item_escape_html_chars">escape_HTML_chars</a></strong>

<dd>
<pre>
    escape_HTML_chars=&gt;1</pre>
</dd>
<dd>
<p>turn &amp; &lt; &gt; into &amp;amp; &amp;gt; &amp;lt;
(default: true)</p>
</dd>
<dt><strong><a name="item_explicit_headings">explicit_headings</a></strong>

<dd>
<pre>
    explicit_headings=&gt;1</pre>
</dd>
<dd>
<p>Don't try to find any headings except the ones specified in the
--custom_heading_regexp option.
Also, the custom headings will not be assigned levels in the order they
are encountered in the document, but in the order they are specified on
the command line.
(default: false)</p>
</dd>
<dt><strong><a name="item_extract">extract</a></strong>

<dd>
<pre>
    extract=&gt;1</pre>
</dd>
<dd>
<p>Extract Mode; don't put HTML headers or footers on the result, just
the plain HTML (thus making the result suitable for inserting into
another document (or as part of the output of a CGI script).
(default: false)</p>
</dd>
<dt><strong><a name="item_hrule_min">hrule_min</a></strong>

<dd>
<pre>
    hrule_min=&gt;I&lt;n&gt;</pre>
</dd>
<dd>
<p>Min number of ---s for an HRule.
(default: 4)</p>
</dd>
<dt><strong><a name="item_indent_width">indent_width</a></strong>

<dd>
<pre>
    indent_width=&gt;I&lt;n&gt;</pre>
</dd>
<dd>
<p>Indents this many spaces for each level of a list.
(default: 2)</p>
</dd>
<dt><strong><a name="item_indent_par_break">indent_par_break</a></strong>

<dd>
<pre>
    indent_par_break=&gt;1</pre>
</dd>
<dd>
<p>Treat paragraphs marked solely by indents as breaks with indents.
That is, instead of taking a three-space indent as a new paragraph,
put in a &lt;BR&gt; and three non-breaking spaces instead.
(see also --preserve_indent)
(default: false)</p>
</dd>
<dt><strong><a name="item_infile">infile</a></strong>

<dd>
<pre>
    infile=&gt;\@my_files
    infile=&gt;['chapter1.txt', 'chapter2.txt']
    &quot;--infile&quot;, &quot;chapter1.txt&quot;, &quot;--infile&quot;, &quot;chapter2.txt&quot;</pre>
</dd>
<dd>
<p>The name of the input file(s).  When the arguments are given as a hash,
this expects a reference to an array of filenames.  When the arguments
are given as a reference to an array, then the ``--infile'' option must
be repeated for each new file added to the list.  If you want to reset
the list to be empty, give the special value of ``CLEAR''.</p>
</dd>
<dd>
<p>The special filename '-' designates STDIN.</p>
</dd>
<dd>
<p>See also <a href="#item_inhandle">inhandle</a> and <a href="#item_instring">instring</a>.</p>
</dd>
<dd>
<p>(default:-)</p>
</dd>
<dt><strong><a name="item_inhandle">inhandle</a></strong>

<dd>
<pre>
    inhandle=&gt;\@my_handles
    inhandle=&gt;[\*MYINHANDLE, \*STDIN]</pre>
</dd>
<dd>
<p>An array of input filehandles; use this instead of
<a href="#item_infile">infile</a> or <a href="#item_instring">instring</a> to use a filehandle or filehandles
as input.</p>
</dd>
<dt><strong><a name="item_instring">instring</a></strong>

<dd>
<pre>
    instring=&gt;\@my_strings
    instring=&gt;[$string1, $string2]</pre>
</dd>
<dd>
<p>An array of input strings; use this instead of
<a href="#item_infile">infile</a> or <a href="#item_inhandle">inhandle</a> to use a string or strings
as input.</p>
</dd>
<dt><strong><a name="item_italic_delimiter">italic_delimiter</a></strong>

<dd>
<pre>
    italic_delimiter=&gt;I&lt;string&gt;</pre>
</dd>
<dd>
<p>This defines what character (or string) is taken to be the delimiter of
text which is to be interpreted as italic (that is, to be given a EM
tag).  If this is empty, no italicising of text will be done.
(default: *)</p>
</dd>
<dt><strong><a name="item_underline_delimiter">underline_delimiter</a></strong>

<dd>
<pre>
    underline_delimiter=&gt;I&lt;string&gt;</pre>
</dd>
<dd>
<p>This defines what character (or string) is taken to be the delimiter of
text which is to be interpreted as underlined (that is, to be given a U
tag).  If this is empty, no underlining of text will be done.
(default: _)</p>
</dd>
<dt><strong><a name="item_links_dictionaries">links_dictionaries</a></strong>

<dd>
<pre>
    links_dictionaries=&gt;\@my_link_dicts
    links_dictionaries=&gt;['url_links.dict', 'format_links.dict']
    &quot;--links_dictionaries&quot;, &quot;url_links.dict&quot;, &quot;--links_dictionaries&quot;, &quot;format_links.dict&quot;</pre>
</dd>
<dd>
<p><code>File(s)</code> to use as a link-dictionary.  There can be more than one of
these.  These are in addition to the Global Link Dictionary and the User
Link Dictionary.  When the arguments are given as a hash, this expects a
reference to an array of filenames.  When the arguments are given as a
reference to an array, then the ``--links_dictionaries'' option must be
repeated for each new file added to the list.  If you want to reset the
list to be empty, give the special value of ``CLEAR''.</p>
</dd>
<dt><strong><a name="item_link_only">link_only</a></strong>

<dd>
<pre>
    link_only=&gt;1</pre>
</dd>
<dd>
<p>Do no escaping or marking up at all, except for processing the links
dictionary file and applying it.  This is useful if you want to use
the linking feature on an HTML document.  If the HTML is a
complete document (includes HTML,HEAD,BODY tags, etc) then you'll
probably want to use the --extract option also.
(default: false)</p>
</dd>
<dt><strong><a name="item_lower_case_tags">lower_case_tags</a></strong>

<dd>
<pre>
     lower_case_tags=&gt;1</pre>
</dd>
<dd>
<p>Force all tags to be in lower-case.</p>
</dd>
<dt><strong><a name="item_mailmode">mailmode</a></strong>

<dd>
<pre>
    mailmode=&gt;1</pre>
</dd>
<dd>
<p>Deal with mail headers &amp; quoted text.  The mail header paragraph is
given the class 'mail_header', and mail-quoted text is given the class
'quote_mail'.
(default: false)</p>
</dd>
<dt><strong><a name="item_make_anchors">make_anchors</a></strong>

<dd>
<pre>
    make_anchors=&gt;0</pre>
</dd>
<dd>
<p>Should we try to make anchors in headings?
(default: true)</p>
</dd>
<dt><strong><a name="item_make_links">make_links</a></strong>

<dd>
<pre>
    make_links=&gt;0</pre>
</dd>
<dd>
<p>Should we try to build links?  If this is false, then the links
dictionaries are not consulted and only structural text-to-HTML
conversion is done.  (default: true)</p>
</dd>
<dt><strong><a name="item_make_tables">make_tables</a></strong>

<dd>
<pre>
    make_tables=&gt;1</pre>
</dd>
<dd>
<p>Should we try to build tables?  If true, spots tables and marks them up
appropriately.  See <a href="#input_file_format">Input File Format</a> for information on how tables
should be formatted.</p>
</dd>
<dd>
<p>This overrides the detection of lists; if something looks like a table,
it is taken as a table, and list-checking is not done for that
paragraph.</p>
</dd>
<dd>
<p>(default: false)</p>
</dd>
<dt><strong><a name="item_min_caps_length">min_caps_length</a></strong>

<dd>
<pre>
    min_caps_length=&gt;I&lt;n&gt;</pre>
</dd>
<dd>
<p>min sequential CAPS for an all-caps line
(default: 3)</p>
</dd>
<dt><strong><a name="item_outfile">outfile</a></strong>

<dd>
<pre>
    outfile=&gt;I&lt;filename&gt;</pre>
</dd>
<dd>
<p>The name of the output file.  If it is ``-'' then the output goes
to Standard Output.
(default: - )</p>
</dd>
<dt><strong><a name="item_outhandle">outhandle</a></strong>

<dd>
<p>The output filehandle; if this is given then the output goes
to this filehandle instead of to the file given in <a href="#item_outfile">outfile</a>.</p>
</dd>
</li>
<dt><strong><a name="item_par_indent">par_indent</a></strong>

<dd>
<pre>
    par_indent=&gt;I&lt;n&gt;</pre>
</dd>
<dd>
<p>Minumum number of spaces indented in first lines of paragraphs.
  Only used when there's no blank line
preceding the new paragraph.
(default: 2)</p>
</dd>
<dt><strong><a name="item_preformat_trigger_lines">preformat_trigger_lines</a></strong>

<dd>
<pre>
    preformat_trigger_lines=&gt;I&lt;n&gt;</pre>
</dd>
<dd>
<p>How many lines of preformatted-looking text are needed to switch to &lt;PRE&gt;
          &lt;= 0 : Preformat entire document
             1 : one line triggers
          &gt;= 2 : two lines trigger</p>
</dd>
<dd>
<p>(default: 2)</p>
</dd>
<dt><strong><a name="item_endpreformat_trigger_lines">endpreformat_trigger_lines</a></strong>

<dd>
<pre>
    endpreformat_trigger_lines=&gt;I&lt;n&gt;</pre>
</dd>
<dd>
<p>How many lines of unpreformatted-looking text are needed to switch from &lt;PRE&gt;
           &lt;= 0 : Never preformat within document
              1 : one line triggers
           &gt;= 2 : two lines trigger
(default: 2)</p>
</dd>
<dd>
<p>NOTE for preformat_trigger_lines and endpreformat_trigger_lines:
A zero takes precedence.  If one is zero, the other is ignored.
If both are zero, entire document is preformatted.</p>
</dd>
<dt><strong><a name="item_preformat_start_marker">preformat_start_marker</a></strong>

<dd>
<pre>
    preformat_start_marker=&gt;I&lt;regexp&gt;</pre>
</dd>
<dd>
<p>What flags the start of a preformatted section if --use_preformat_marker
is true.</p>
</dd>
<dd>
<p>(default: ``^(:?(:?&amp;lt;)|&lt;)PRE(:?(:?&amp;gt;)|&gt;)\$'')</p>
</dd>
<dt><strong><a name="item_preformat_end_marker">preformat_end_marker</a></strong>

<dd>
<pre>
    preformat_end_marker=&gt;I&lt;regexp&gt;</pre>
</dd>
<dd>
<p>What flags the end of a preformatted section if --use_preformat_marker
is true.</p>
</dd>
<dd>
<p>(default: ``^(:?(:?&amp;lt;)|&lt;)/PRE(:?(:?&amp;gt;)|&gt;)\$'')</p>
</dd>
<dt><strong><a name="item_preformat_whitespace_min">preformat_whitespace_min</a></strong>

<dd>
<pre>
    preformat_whitespace_min=&gt;I&lt;n&gt;</pre>
</dd>
<dd>
<p>Minimum number of consecutive whitespace characters to trigger
normal preformatting. 
NOTE: Tabs are expanded to spaces before this check is made.
That means if <strong>tab_width</strong> is 8 and this is 5, then one tab may be
expanded to 8 spaces, which is enough to trigger preformatting.
(default: 5)</p>
</dd>
<dt><strong><a name="item_prepend_file">prepend_file</a></strong>

<dd>
<pre>
    prepend_file=&gt;I&lt;filename&gt;</pre>
</dd>
<dd>
<p>If you want something prepended to the processed body text, put the
filename here.  The prepended text will not be processed at all, so make
sure it's plain text or decent HTML.</p>
</dd>
<dd>
<p>(default: nothing)</p>
</dd>
<dt><strong><a name="item_preserve_indent">preserve_indent</a></strong>

<dd>
<pre>
    preserve_indent=&gt;1</pre>
</dd>
<dd>
<p>Preserve the first-line indentation of paragraphs marked with indents
by replacing the spaces of the first line with non-breaking spaces.
(default: false)</p>
</dd>
<dt><strong><a name="item_short_line_length">short_line_length</a></strong>

<dd>
<pre>
    short_line_length=&gt;I&lt;n&gt;</pre>
</dd>
<dd>
<p>Lines this short (or shorter) must be intentionally broken and are kept
that short.
(default: 40)</p>
</dd>
<dt><strong><a name="item_style_url">style_url</a></strong>

<dd>
<pre>
    style_url=&gt;I&lt;url&gt;</pre>
</dd>
<dd>
<p>This gives the URL of a stylesheet; a LINK tag will be added to the
output.</p>
</dd>
<dt><strong><a name="item_tab_width">tab_width</a></strong>

<dd>
<pre>
    tab_width=&gt;I&lt;n&gt;</pre>
</dd>
<dd>
<p>How many spaces equal a tab?
(default: 8)</p>
</dd>
<dt><strong><a name="item_table_type">table_type</a></strong>

<dd>
<pre>

    table_type=&gt;{ ALIGN=&gt;0, PGSQL=&gt;0, BORDER=&gt;1, DELIM=&gt;0 }</pre>
</dd>
<dd>
<p>This determines which types of tables will be recognised when ``make_tables''
is true.  The possible types are ALIGN, PGSQL, BORDER and DELIM.
(default: all types are true)</p>
</dd>
<dt><strong><a name="item_title">title</a></strong>

<dd>
<pre>
    title=&gt;I&lt;title&gt;</pre>
</dd>
<dd>
<p>You can specify a title.  Otherwise it will use a blank one.
(default: nothing)</p>
</dd>
<dt><strong><a name="item_titlefirst">titlefirst</a></strong>

<dd>
<pre>
    titlefirst=&gt;1</pre>
</dd>
<dd>
<p>Use the first non-blank line as the title.</p>
</dd>
<dt><strong><a name="item_underline_length_tolerance">underline_length_tolerance</a></strong>

<dd>
<pre>
    underline_length_tolerance=&gt;I&lt;n&gt;</pre>
</dd>
<dd>
<p>How much longer or shorter can underlines be and still be underlines?
(default: 1)</p>
</dd>
<dt><strong><a name="item_underline_offset_tolerance">underline_offset_tolerance</a></strong>

<dd>
<pre>
    underline_offset_tolerance=&gt;I&lt;n&gt;</pre>
</dd>
<dd>
<p>How far offset can underlines be and still be underlines?
(default: 1)</p>
</dd>
<dt><strong><a name="item_unhyphenation">unhyphenation</a></strong>

<dd>
<pre>
    unhyphenation=&gt;0</pre>
</dd>
<dd>
<p>Enables unhyphenation of text.
(default: true)</p>
</dd>
<dt><strong><a name="item_use_mosaic_header">use_mosaic_header</a></strong>

<dd>
<pre>
    use_mosaic_header=&gt;1</pre>
</dd>
<dd>
<p>Use this option if you want to force the heading styles to match what Mosaic
outputs.  (Underlined with ``***''s is H1,
with ``===''s is H2, with ``+++'' is H3, with ``---'' is H4, with ``~~~'' is H5
and with ``...'' is H6)
This was the behavior of txt2html up to version 1.10.
(default: false)</p>
</dd>
<dt><strong><a name="item_use_preformat_marker">use_preformat_marker</a></strong>

<dd>
<pre>
    use_preformat_marker=&gt;1</pre>
</dd>
<dd>
<p>Turn on preformatting when encountering ``&lt;PRE&gt;'' on a line by itself, and turn
it off when there's a line containing only ``&lt;/PRE&gt;''.
When such preformatted text is detected, the PRE tag will be given the
class 'quote_explicit'.
(default: off)</p>
</dd>
<dt><strong><a name="item_xhtml">xhtml</a></strong>

<dd>
<pre>
    xhtml=&gt;1</pre>
</dd>
<dd>
<p>Try to make the output conform to the XHTML standard, including
closing all open tags and marking empty tags correctly.  This
turns on --lower_case_tags and overrides the --doctype option.
Note that if you add a header or a footer file, it is up to you
to make it conform; the header/footer isn't touched by this.
Likewise, if you make link-dictionary entries that break XHTML,
then this won't fix them, except to the degree of putting all tags
into lower-case.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<p>
</p>
<h2><a name="new">new</a></h2>
<pre>
    $conv = new HTML::TextToHTML()</pre>
<pre>
    $conv = new HTML::TextToHTML(titlefirst=&gt;1,
        ...
    );</pre>
<p>Create a new object with new.  If one argument is given, it is assumed
to be a reference to an array of arguments.  If more than one argument
is given, it is assumed to be a hash of arguments.  These arguments will
be used in invocations of other methods.</p>
<p>See <a href="#options">OPTIONS</a> for the possible values of the arguments.</p>
<p>
</p>
<h2><a name="args">args</a></h2>
<pre>
    $conv-&gt;args(short_line_length=&gt;60,
        titlefirst=&gt;1,
        ....
    );</pre>
<p>Updates the current arguments/options of the HTML::TextToHTML object.
Takes either a hash, or a reference to an array of arguments, which will
be used in invocations of other methods.
See <a href="#options">OPTIONS</a> for the possible values of the arguments.</p>
<p>NOTE: the reference-to-an-array usage is DEPRECATED and will be removed
in the future.</p>
<p>
</p>
<h2><a name="process_chunk">process_chunk</a></h2>
<p>$newstring = $conv-&gt;process_chunk($mystring);</p>
<p>Convert a string to a HTML fragment.  This assumes that this string is
at the least, a single paragraph, but it can contain more than that.
This returns the processed string.  If you want to pass arguments to
alter the behaviour of this conversion, you need to do that earlier,
either when you create the object, or with the <a href="#args">args</a> method.</p>
<pre>
    $newstring = $conv-&gt;process_chunk($mystring,
                            close_tags=&gt;0);</pre>
<p>If there are open tags (such as lists) in the input string,
process_chunk will now automatically close them, unless you specify not
to, with the close_tags option.</p>
<pre>
    $newstring = $conv-&gt;process_chunk($mystring,
                            is_fragment=&gt;1);</pre>
<p>If you want this string to be treated as a fragment, and not assumed to
be a paragraph, set is_fragment to true.  If there is more than one
paragraph in the string (ie it contains blank lines) then this option
will be ignored.</p>
<p>
</p>
<h2><a name="process_para">process_para</a></h2>
<p>$newstring = $conv-&gt;process_para($mystring);</p>
<p>Convert a string to a HTML fragment.  This assumes that this string is
at the most a single paragraph, with no blank lines in it.  If you don't
know whether your string will contain blank lines or not, use the
<a href="#process_chunk">process_chunk</a> method instead.</p>
<p>This returns the processed string.  If you want to pass arguments to
alter the behaviour of this conversion, you need to do that earlier,
either when you create the object, or with the <a href="#args">args</a> method.</p>
<pre>
    $newstring = $conv-&gt;process_para($mystring,
                            close_tags=&gt;0);</pre>
<p>If there are open tags (such as lists) in the input string, process_para
will now automatically close them, unless you specify not to, with the
close_tags option.</p>
<pre>
    $newstring = $conv-&gt;process_para($mystring,
                            is_fragment=&gt;1);</pre>
<p>If you want this string to be treated as a fragment, and not assumed to be
a paragraph, set is_fragment to true.</p>
<p>
</p>
<h2><a name="txt2html">txt2html</a></h2>
<pre>
    $conv-&gt;txt2html(%args);</pre>
<p>Convert a text file to HTML.  Takes a hash of arguments, or a reference
to an array of arguments to customize the conversion; (this includes
saying what file to convert!) See <a href="#options">OPTIONS</a> for the possible values of
the arguments.  Arguments which have already been set with <strong>new</strong> or
<strong>args</strong> will remain as they are, unless they are overridden.</p>
<p>
</p>
<hr />
<h1><a name="private_methods">PRIVATE METHODS</a></h1>
<p>These are methods used internally, only of interest to developers.</p>
<p>
</p>
<h2><a name="init_our_data">init_our_data</a></h2>
<p>$self-&gt;init_our_data();</p>
<p>Initializes the internal object data.</p>
<p>
</p>
<h2><a name="deal_with_options">deal_with_options</a></h2>
<p>$self-&gt;deal_with_options();</p>
<p>do extra processing related to particular options</p>
<p>
</p>
<h2><a name="escape">escape</a></h2>
<p>$newtext = escape($text);</p>
<p>Escape &amp; &lt; and &gt;</p>
<p>
</p>
<h2><a name="demoronize_char">demoronize_char</a></h2>
<p>$newtext = demoronize_char($text);</p>
<p>Convert Microsoft character entities into characters.</p>
<p>Added by Alan Jackson, alan at ajackson dot org, and based
on the demoronize script by John Walker, <a href="http://www.fourmilab.ch/">http://www.fourmilab.ch/</a></p>
<p>
</p>
<h2><a name="demoronize_code">demoronize_code</a></h2>
<p>$newtext = demoronize_code($text);</p>
<p>convert Microsoft character entities into HTML code</p>
<p>
</p>
<h2><a name="get_tag">get_tag</a></h2>
<p>$tag = $self-&gt;get_tag($in_tag);</p>
<p><table cellspacing="0" cellpadding="0"><tr><td>$tag = $self-&gt;get_tag($in_tag,
<tr><td><td>tag_type=&gt;'start',
<tr><td><td>inside_tag=&gt;'');</table></p>
<p>output the tag wanted (add the &lt;&gt; and the / if necessary)
- output in lower or upper case
- do tag-related processing
options:
  tag_type=&gt;'start' | tag_type=&gt;'end' | tag_type=&gt;'empty'
  (default start)
  inside_tag=&gt;string (default empty)</p>
<p>
</p>
<h2><a name="close_tag">close_tag</a></h2>
<p>$tag = $self-&gt;close_tag($in_tag);</p>
<p>close the open tag</p>
<p>
</p>
<h2><a name="hrule">hrule</a></h2>
<pre>
   $self-&gt;hrule(para_lines_ref=&gt;$para_lines,
             para_action_ref=&gt;$para_action,
             ind=&gt;0);</pre>
<p>Deal with horizontal rules.</p>
<p>
</p>
<h2><a name="shortline">shortline</a></h2>
<pre>
    $self-&gt;shortline(line_ref=&gt;$line_ref,
                     line_action_ref=&gt;$line_action_ref,
                     prev_ref=&gt;$prev_ref,
                     prev_action_ref=&gt;$prev_action_ref,
                     prev_line_len=&gt;$prev_line_len);</pre>
<p>Deal with short lines.</p>
<p>
</p>
<h2><a name="is_mailheader">is_mailheader</a></h2>
<pre>
    if ($self-&gt;is_mailheader(rows_ref=&gt;$rows_ref))
    {
        ...
    }</pre>
<p>Is this a mailheader line?
=cut
sub is_mailheader ($%)
{
    my $self = shift;
    my %args = (
        rows_ref =&gt; undef,
        @_
    );
    my $rows_ref = $args{rows_ref};</p>
<pre>
    # a mail header is assumed to be the whole
    # paragraph which starts with a From , From: or Newsgroups: line</pre>
<pre>
    if ($rows_ref-&gt;[0] =~ /^(From:?)|(Newsgroups:) /)
    {
        return 1;
    }
    return 0;</pre>
<p>}    # is_mailheader</p>
<p>
</p>
<h2><a name="mailheader">mailheader</a></h2>
<pre>
    $self-&gt;mailheader(rows_ref=&gt;$rows_ref);</pre>
<p>Deal with a mailheader.</p>
<p>
</p>
<h2><a name="mailquote">mailquote</a></h2>
<pre>
    $self-&gt;mailquote(line_ref=&gt;$line_ref,
                     line_action_ref=&gt;$line_action_ref,
                     prev_ref=&gt;$prev_ref,
                     prev_action_ref=&gt;$prev_action_ref,
                     next_ref=&gt;$next_ref);</pre>
<p>Deal with quoted mail.</p>
<p>
</p>
<h2><a name="subtract_modes">subtract_modes</a></h2>
<pre>

    $newvector = subtract_modes($vector, $mask);</pre>
<p>Subtracts modes listed in $mask from $vector.</p>
<p>
</p>
<h2><a name="paragraph">paragraph</a></h2>
<pre>
    $self-&gt;paragraph(line_ref=&gt;$line_ref,
                     line_action_ref=&gt;$line_action_ref,
                     prev_ref=&gt;$prev_ref,
                     prev_action_ref=&gt;$prev_action_ref,
                     line_indent=&gt;$line_indent,
                     prev_indent=&gt;$prev_indent,
                     is_fragment=&gt;$is_fragment,
                     ind=&gt;$ind);</pre>
<p>Detect paragraph indentation.</p>
<p>
</p>
<h2><a name="listprefix">listprefix</a></h2>
<pre>
    ($prefix, $number, $rawprefix, $term) = $self-&gt;listprefix($line);</pre>
<p>Detect and parse a list item.</p>
<p>
</p>
<h2><a name="startlist">startlist</a></h2>
<pre>
    $self-&gt;startlist(prefix=&gt;$prefix,
                     number=&gt;0,
                     rawprefix=&gt;$rawprefix,
                     term=&gt;$term,
                     para_lines_ref=&gt;$para_lines_ref,
                     para_action_ref=&gt;$para_action_ref,
                     ind=&gt;0,
                     prev_ref=&gt;$prev_ref,
                     total_prefix=&gt;$total_prefix);</pre>
<p>Start a list.</p>
<p>
</p>
<h2><a name="endlist">endlist</a></h2>
<pre>
    $self-&gt;endlist(num_lists=&gt;0,
        prev_ref=&gt;$prev_ref,
        line_action_ref=&gt;$line_action_ref);</pre>
<p>End N lists</p>
<p>
</p>
<h2><a name="continuelist">continuelist</a></h2>
<pre>
    $self-&gt;continuelist(para_lines_ref=&gt;$para_lines_ref,
                        para_action_ref=&gt;$para_action_ref,
                        ind=&gt;0,
                        term=&gt;$term);</pre>
<p>Continue a list.</p>
<p>
</p>
<h2><a name="liststuff">liststuff</a></h2>
<pre>
    $self-&gt;liststuff(para_lines_ref=&gt;$para_lines_ref,
                     para_action_ref=&gt;$para_action_ref,
                     para_line_indent_ref=&gt;$para_line_indent_ref,
                     ind=&gt;0,
                     prev_ref=&gt;$prev_ref);</pre>
<p>Process a list (higher-level method).</p>
<p>
</p>
<h2><a name="get_table_type">get_table_type</a></h2>
<pre>
    $table_type = $self-&gt;get_table_type(rows_ref=&gt;$rows_ref,
                                        para_len=&gt;0);</pre>
<p>Figure out the table type of this table, if any</p>
<p>
</p>
<h2><a name="is_aligned_table">is_aligned_table</a></h2>
<pre>
    if ($self-&gt;is_aligned_table(rows_ref=&gt;$rows_ref, para_len=&gt;0))
    {
        ...
    }</pre>
<p>Check if the given paragraph-array is an aligned table</p>
<p>
</p>
<h2><a name="is_pgsql_table">is_pgsql_table</a></h2>
<pre>
    if ($self-&gt;is_pgsql_table(rows_ref=&gt;$rows_ref, para_len=&gt;0))
    {
        ...
    }</pre>
<p>Check if the given paragraph-array is a Postgresql table
(the ascii format produced by Postgresql)</p>
<p>A PGSQL table can start with an optional table-caption,
    then it has a row of column headings separated by |
    then it has a row of ------+-----
    then it has one or more rows of column values separated by |
    then it has a row-count (N rows)</p>
<p>
</p>
<h2><a name="is_border_table">is_border_table</a></h2>
<pre>
    if ($self-&gt;is_border_table(rows_ref=&gt;$rows_ref, para_len=&gt;0))
    {
        ...
    }</pre>
<p>Check if the given paragraph-array is a Border table.</p>
<p>A BORDER table can start with an optional table-caption,
    then it has a row of +------+-----+
    then it has a row of column headings separated by |
    then it has a row of +------+-----+
    then it has one or more rows of column values separated by |
    then it has a row of +------+-----+</p>
<p>
</p>
<h2><a name="is_delim_table">is_delim_table</a></h2>
<pre>
    if ($self-&gt;is_delim_table(rows_ref=&gt;$rows_ref, para_len=&gt;0))
    {
        ...
    }</pre>
<p>Check if the given paragraph-array is a Delimited table.</p>
<p>A DELIM table can start with an optional table-caption,
then it has at least two rows which start and end and are
punctuated by a non-alphanumeric delimiter.</p>
<pre>
    | val1 | val2 |
    | val3 | val4 |</pre>
<p>
</p>
<h2><a name="tablestuff">tablestuff</a></h2>
<pre>
    $self-&gt;tablestuff(table_type=&gt;0,
                      rows_ref=&gt;$rows_ref,
                      para_len=&gt;0);</pre>
<p>Process a table.</p>
<p>
</p>
<h2><a name="make_aligned_table">make_aligned_table</a></h2>
<pre>
    $self-&gt;make_aligned_table(rows_ref=&gt;$rows_ref,
                              para_len=&gt;0);</pre>
<p>Make an Aligned table.</p>
<p>
</p>
<h2><a name="make_pgsql_table">make_pgsql_table</a></h2>
<pre>
    $self-&gt;make_pgsql_table(rows_ref=&gt;$rows_ref,
                              para_len=&gt;0);</pre>
<p>Make a PGSQL table.</p>
<p>
</p>
<h2><a name="make_border_table">make_border_table</a></h2>
<pre>
    $self-&gt;make_border_table(rows_ref=&gt;$rows_ref,
                             para_len=&gt;0);</pre>
<p>Make a BORDER table.</p>
<p>
</p>
<h2><a name="make_delim_table">make_delim_table</a></h2>
<pre>
    $self-&gt;make_delim_table(rows_ref=&gt;$rows_ref,
                            para_len=&gt;0);</pre>
<p>Make a Delimited table.</p>
<p>
</p>
<h2><a name="is_preformatted">is_preformatted</a></h2>
<pre>
    if ($self-&gt;is_preformatted($line))
    {
        ...
    }</pre>
<p>Returns true if the passed string is considered to be preformatted.</p>
<p>
</p>
<h2><a name="split_end_explicit_preformat">split_end_explicit_preformat</a></h2>
<pre>
    $front = $self-&gt;split_end_explicit_preformat(para_ref=&gt;$para_ref);</pre>
<p>Modifies the given string, and returns the front preformatted part.</p>
<p>
</p>
<h2><a name="endpreformat">endpreformat</a></h2>
<pre>
    $self-&gt;endpreformat(para_lines_ref=&gt;$para_lines_ref,
                        para_action_ref=&gt;$para_action_ref,
                        ind=&gt;0,
                        prev_ref=&gt;$prev_ref);</pre>
<p>End a preformatted section.</p>
<p>
</p>
<h2><a name="preformat">preformat</a></h2>
<pre>
    $self-&gt;preformat(mode_ref=&gt;$mode_ref,
                     line_ref=&gt;$line_ref,
                     line_action_ref=&gt;$line_action_ref,
                     prev_ref=&gt;$prev_ref,
                     next_ref=&gt;$next_ref,
                     prev_action_ref);</pre>
<p>Detect and process a preformatted section.
=cut
sub preformat ($%)
{
    my $self = shift;
    my %args = (
        mode_ref        =&gt; undef,
        line_ref        =&gt; undef,
        line_action_ref =&gt; undef,
        prev_ref        =&gt; undef,
        next_ref        =&gt; undef,
        prev_action_ref =&gt; undef,
        @_
    );
    my $mode_ref        = $args{mode_ref};
    my $line_ref        = $args{line_ref};
    my $line_action_ref = $args{line_action_ref};
    my $prev_ref        = $args{prev_ref};
    my $next_ref        = $args{next_ref};
    my $prev_action_ref = $args{prev_action_ref};</p>
<pre>
    my $tag = '';
    if ($self-&gt;{use_preformat_marker})
    {
        my $pstart = $self-&gt;{preformat_start_marker};
        if (${$line_ref} =~ /$pstart/io)
        {
            if (${$prev_ref} =~ s/&lt;P&gt;$//)
            {
                pop @{$self-&gt;{__tags}};
            }
            $tag =
              $self-&gt;get_tag('PRE', inside_tag =&gt; &quot; class='quote_explicit'&quot;);
            ${$line_ref} = &quot;${tag}\n&quot;;
            ${$mode_ref}        |= $PRE | $PRE_EXPLICIT;
            ${$line_action_ref} |= $PRE;
            return;
        }
    }</pre>
<pre>
    if (
           !(${$line_action_ref} &amp; $MAILQUOTE)
        &amp;&amp; !(${$prev_action_ref} &amp; $MAILQUOTE)
        &amp;&amp; (
            $self-&gt;{preformat_trigger_lines} == 0
            || (
                $self-&gt;is_preformatted(${$line_ref})
                &amp;&amp; (
                    $self-&gt;{preformat_trigger_lines} == 1
                    || (defined $next_ref
                        &amp;&amp; $self-&gt;is_preformatted(${$next_ref}))
                )
            )
        )
      )
    {
        if (${$prev_ref} =~ s/&lt;P&gt;$//)
        {
            pop @{$self-&gt;{__tags}};
        }
        $tag = $self-&gt;get_tag('PRE');
        ${$line_ref} =~ s/^/${tag}\n/;
        ${$mode_ref}        |= $PRE;
        ${$line_action_ref} |= $PRE;
    }
}    # preformat</pre>
<p>
</p>
<h2><a name="make_new_anchor">make_new_anchor</a></h2>
<pre>
    $anchor = $self-&gt;make_new_anchor($heading_level);</pre>
<p>Make a new anchor.
=cut
sub make_new_anchor ($$)
{
    my $self          = shift;
    my $heading_level = shift;</p>
<pre>
    my ($anchor, $i);</pre>
<pre>
    return sprintf(&quot;%d&quot;, $self-&gt;{__non_header_anchor}++) if (!$heading_level);</pre>
<pre>
    $anchor = &quot;section&quot;;
    $self-&gt;{__heading_count}-&gt;[$heading_level - 1]++;</pre>
<pre>
    # Reset lower order counters
    for ($i = @{$self-&gt;{__heading_count}}; $i &gt; $heading_level; $i--)
    {
        $self-&gt;{__heading_count}-&gt;[$i - 1] = 0;
    }</pre>
<pre>
    for ($i = 0; $i &lt; $heading_level; $i++)
    {
        $self-&gt;{__heading_count}-&gt;[$i] = 1
          if !$self-&gt;{__heading_count}-&gt;[$i];    # In case they skip any
        $anchor .= sprintf(&quot;_%d&quot;, $self-&gt;{__heading_count}-&gt;[$i]);
    }
    chomp($anchor);
    $anchor;
}    # make_new_anchor</pre>
<p>
</p>
<h2><a name="anchor_mail">anchor_mail</a></h2>
<pre>
    $self-&gt;anchor_mail($line_ref);</pre>
<p>Make an anchor for a mail section.
=cut
sub anchor_mail ($$)
{
    my $self     = shift;
    my $line_ref = shift;</p>
<pre>
    if ($self-&gt;{make_anchors})
    {
        my ($anchor) = $self-&gt;make_new_anchor(0);
        if ($self-&gt;{lower_case_tags})
        {
            ${$line_ref} =~ s/([^ ]*)/&lt;a name=&quot;$anchor&quot;&gt;$1&lt;\/a&gt;/;
        }
        else
        {
            ${$line_ref} =~ s/([^ ]*)/&lt;A NAME=&quot;$anchor&quot;&gt;$1&lt;\/A&gt;/;
        }
    }
}    # anchor_mail</pre>
<p>
</p>
<h2><a name="anchor_heading">anchor_heading</a></h2>
<pre>
    $self-&gt;anchor_heading($heading_level, $line_ref);</pre>
<p>Make an anchor for a heading.
=cut
sub anchor_heading ($$$)
{
    my $self     = shift;
    my $level    = shift;
    my $line_ref = shift;</p>
<pre>
    if ($self-&gt;{dict_debug} &amp; 8)
    {
        print STDERR &quot;anchor_heading: &quot;, ${$line_ref}, &quot;\n&quot;;
    }
    if ($self-&gt;{make_anchors})
    {
        my ($anchor) = $self-&gt;make_new_anchor($level);
        if ($self-&gt;{lower_case_tags})
        {
            ${$line_ref} =~ s/(&lt;h.&gt;)(.*)(&lt;\/h.&gt;)/$1&lt;a name=&quot;$anchor&quot;&gt;$2&lt;\/a&gt;$3/;
        }
        else
        {
            ${$line_ref} =~ s/(&lt;H.&gt;)(.*)(&lt;\/H.&gt;)/$1&lt;A NAME=&quot;$anchor&quot;&gt;$2&lt;\/A&gt;$3/;
        }
    }
    if ($self-&gt;{dict_debug} &amp; 8)
    {
        print STDERR &quot;anchor_heading(after): &quot;, ${$line_ref}, &quot;\n&quot;;
    }
}    # anchor_heading</pre>
<p>
</p>
<h2><a name="heading_level">heading_level</a></h2>
<pre>
    $self-&gt;heading_level($style);</pre>
<p>Add a new heading style if this is a new heading style.
=cut
sub heading_level ($$)
{
    my $self = shift;</p>
<pre>
    my ($style) = @_;
    $self-&gt;{__heading_styles}-&gt;{$style} = ++$self-&gt;{__num_heading_styles}
      if !$self-&gt;{__heading_styles}-&gt;{$style};
    $self-&gt;{__heading_styles}-&gt;{$style};
}    # heading_level</pre>
<p>
</p>
<h2><a name="is_ul_list_line">is_ul_list_line</a></h2>
<pre>
    if ($self-&gt;is_ul_list_line($line))
    {
        ...
    }</pre>
<p>Tests if this line starts a UL list item.</p>
<p>
</p>
<h2><a name="is_heading">is_heading</a></h2>
<pre>
    if ($self-&gt;is_heading(line_ref=&gt;$line_ref, next_ref=&gt;$next_ref))
    {
        ...
    }</pre>
<p>Tests if this line is a heading.  Needs to take account of the
next line, because a standard heading is defined by ``underlining''
the text of the heading.</p>
<p>
</p>
<h2><a name="heading">heading</a></h2>
<pre>

    $self-&gt;heading(line_ref=&gt;$line_ref,
        next_ref=&gt;$next_ref);</pre>
<p>Make a heading
Assumes is_heading is true
=cut
sub heading ($%)
{
    my $self = shift;
    my %args = (
        line_ref =&gt; undef,
        next_ref =&gt; undef,
        @_
    );
    my $line_ref = $args{line_ref};
    my $next_ref = $args{next_ref};</p>
<pre>
    my ($hoffset, $heading) = ${$line_ref} =~ /^(\s*)(.+)$/;
    $hoffset = &quot;&quot; unless defined($hoffset);
    $heading = &quot;&quot; unless defined($heading);
    $heading =~ s/&amp;[^;]+;/X/g;    # Unescape chars so we get an accurate length
    my ($uoffset, $underline) = ${$next_ref} =~ /^(\s*)(\S+)\s*$/;
    $uoffset   = &quot;&quot; unless defined($uoffset);
    $underline = &quot;&quot; unless defined($underline);</pre>
<pre>
    $underline = substr($underline, 0, 1);</pre>
<pre>
    # Call it a different style if the heading is in all caps.
    $underline .= &quot;C&quot; if $self-&gt;iscaps(${$line_ref});
    ${$next_ref} = &quot; &quot;;           # Eat the underline
    $self-&gt;{__heading_level} = $self-&gt;heading_level($underline);
    if ($self-&gt;{escape_HTML_chars})
    {
        ${$line_ref} = escape(${$line_ref});
    }
    $self-&gt;tagline(&quot;H&quot; . $self-&gt;{__heading_level}, $line_ref);
    $self-&gt;anchor_heading($self-&gt;{__heading_level}, $line_ref);
}    # heading</pre>
<p>
</p>
<h2><a name="is_custom_heading">is_custom_heading</a></h2>
<pre>
    if ($self-&gt;is_custom_heading($line))
    {
        ...
    }</pre>
<p>Check if the given line matches a custom heading.
=cut
sub is_custom_heading ($%)
{
    my $self = shift;
    my %args = (
        line =&gt; undef,
        @_
    );
    my $line = $args{line};</p>
<pre>
    foreach my $reg (@{$self-&gt;{custom_heading_regexp}})
    {
        return 1 if ($line =~ /$reg/);
    }
    return 0;
}    # is_custom_heading</pre>
<p>
</p>
<h2><a name="custom_heading">custom_heading</a></h2>
<pre>
    $self-&gt;custom_heading(line_ref=&gt;$line_ref);</pre>
<p>Make a custom heading.  Assumes is_custom_heading is true.
=cut
sub custom_heading ($%)
{
    my $self = shift;
    my %args = (
        line_ref =&gt; undef,
        @_
    );
    my $line_ref = $args{line_ref};</p>
<pre>
    my $level;
    my $i = 0;
    foreach my $reg (@{$self-&gt;{custom_heading_regexp}})
    {
        if (${$line_ref} =~ /$reg/)
        {
            if ($self-&gt;{explicit_headings})
            {
                $level = $i + 1;
            }
            else
            {
                $level = $self-&gt;heading_level(&quot;Cust&quot; . $i);
            }
            if ($self-&gt;{escape_HTML_chars})
            {
                ${$line_ref} = escape(${$line_ref});
            }
            $self-&gt;tagline(&quot;H&quot; . $level, $line_ref);
            $self-&gt;anchor_heading($level, $line_ref);
            last;
        }
        $i++;
    }
}    # custom_heading</pre>
<p>
</p>
<h2><a name="unhyphenate_para">unhyphenate_para</a></h2>
<pre>
    $self-&gt;unhyphenate_para($para_ref);</pre>
<p>Join up hyphenated words that are split across lines.
=cut
sub unhyphenate_para ($$)
{
    my $self     = shift;
    my $para_ref = shift;</p>
<pre>
    # Treating this whole paragraph as one string, look for
    # 1 - whitespace
    # 2 - a word (ending in a hyphen, followed by a newline)
    # 3 - whitespace (starting on the next line)
    # 4 - a word with its punctuation
    # Substitute this with
    # 1-whitespace 2-word 4-word newline 3-whitespace
    # We preserve the 3-whitespace because we don't want to mess up
    # our existing indentation.
    ${$para_ref} =~
      /(\s*)([^\W\d_]*)\-\n(\s*)([^\W\d_]+[\)\}\]\.,:;\'\&quot;\&gt;]*\s*)/s;
    ${$para_ref} =~
s/(\s*)([^\W\d_]*)\-\n(\s*)([^\W\d_]+[\)\}\]\.,:;\'\&quot;\&gt;]*\s*)/$1$2$4\n$3/gs;
}    # unhyphenate_para</pre>
<p>
</p>
<h2><a name="tagline">tagline</a></h2>
<pre>
    $self-&gt;tagline($tag, $line_ref);</pre>
<p>Put the given tag around the given line.
=cut
sub tagline ($$$)
{
    my $self     = shift;
    my $tag      = shift;
    my $line_ref = shift;</p>
<pre>
    chomp ${$line_ref};    # Drop newline
    my $tag1 = $self-&gt;get_tag($tag);
    my $tag2 = $self-&gt;close_tag($tag);
    ${$line_ref} =~ s/^\s*(.*)$/${tag1}$1${tag2}\n/;
}    # tagline</pre>
<p>
</p>
<h2><a name="iscaps">iscaps</a></h2>
<pre>
    if ($self-&gt;iscaps($line))
    {
        ...
    }</pre>
<p>Check if a line is all capitals.
=cut
sub iscaps
{
    my $self = shift;
    local ($_) = @_;</p>
<pre>
    my $min_caps_len = $self-&gt;{min_caps_length};</pre>
<pre>
    /^[^[:lower:]&lt;]*[[:upper:]]{$min_caps_len,}[^[:lower:]&lt;]*$/;
}    # iscaps</pre>
<p>
</p>
<h2><a name="caps">caps</a></h2>
<pre>
    $self-&gt;caps(line_ref=&gt;$line_ref,
                line_action_ref=&gt;$line_action_ref);</pre>
<p>Detect and deal with an all-caps line.
=cut
sub caps
{
    my $self = shift;
    my %args = (
        line_ref        =&gt; undef,
        line_action_ref =&gt; undef,
        @_
    );
    my $line_ref        = $args{line_ref};
    my $line_action_ref = $args{line_action_ref};</p>
<pre>
    if (   $self-&gt;{caps_tag}
        &amp;&amp; $self-&gt;iscaps(${$line_ref}))
    {
        $self-&gt;tagline($self-&gt;{caps_tag}, $line_ref);
        ${$line_action_ref} |= $CAPS;
    }
}    # caps</pre>
<p>
</p>
<h2><a name="do_delim">do_delim</a></h2>
<pre>
    $self-&gt;do_delim(line_ref=&gt;$line_ref,
                    line_action_ref=&gt;$line_action_ref,
                    delim=&gt;'*',
                    tag=&gt;'STRONG');</pre>
<p>Deal with a line which has words delimited by the given delimiter;
this is used to deal with italics, bold and underline formatting.
=cut
sub do_delim
{
    my $self = shift;
    my %args = (
        line_ref        =&gt; undef,
        line_action_ref =&gt; undef,
        delim           =&gt; '*',
        tag             =&gt; 'STRONG',
        @_
    );
    my $line_ref        = $args{line_ref};
    my $line_action_ref = $args{line_action_ref};
    my $delim           = $args{delim};
    my $tag             = $args{tag};</p>
<pre>
    if ($delim eq '#')  
    {
        if (${$line_ref} =~ m/\B#([[:alpha:]])#\B/s)
        {
            ${$line_ref} =~ s/\B#([[:alpha:]])#\B/&lt;${tag}&gt;$1&lt;\/${tag}&gt;/gs;
        }
        # special treatment of # for the #num case and the #link case
        if (${$line_ref} !~ m/&lt;[aA]/)
        {
            ${$line_ref} =~
s/#([^\d#](?![^#]*(?:&lt;li&gt;|&lt;LI&gt;|&lt;P&gt;|&lt;p&gt;))[^#]*[^# \t\n])#/&lt;${tag}&gt;$1&lt;\/${tag}&gt;/gs;
        }
        else
        {
            my $line_with_links = '';
            my $linkme = '';
            my $unmatched = ${$line_ref};
            while ($unmatched =~ 
                   m/#([^\d#](?![^#]*(?:&lt;li&gt;|&lt;LI&gt;|&lt;P&gt;|&lt;p&gt;))[^#]*[^# \t\n])#/s)
            {
                $line_with_links .= $`;
                $linkme = $&amp;;
                $unmatched = $';
                if (!$self-&gt;in_link_context($linkme, $line_with_links))
                {
                    $linkme =~
                        s/#([^\d#](?![^#]*(?:&lt;li&gt;|&lt;LI&gt;|&lt;P&gt;|&lt;p&gt;))[^#]*[^# \t\n])#/&lt;${tag}&gt;$1&lt;\/${tag}&gt;/gs;
                }
                $line_with_links .= $linkme;
            }
            ${$line_ref} = $line_with_links . $unmatched;
        }
    }
    elsif ($delim eq '^')
    {
        ${$line_ref} =~
s/\^((?![^^]*(?:&lt;li&gt;|&lt;LI&gt;|&lt;p&gt;|&lt;P&gt;))(\w|[&quot;'&lt;&gt;])[^^]*)\^/&lt;${tag}&gt;$1&lt;\/${tag}&gt;/gs;
        ${$line_ref} =~ s/\B\^([[:alpha:]])\^\B/&lt;${tag}&gt;$1&lt;\/${tag}&gt;/gs;
    }
    elsif ($delim eq '_')
    {
        if (${$line_ref} =~ m/\B_([[:alpha:]])_\B/s)
        {
            ${$line_ref} =~ s/\B_([[:alpha:]])_\B/&lt;${tag}&gt;$1&lt;\/${tag}&gt;/gs;
        }
        # need to make sure that _ delimiters are not mistaken for
        # a_variable_name
        ${$line_ref} =~
            s#(?&lt;![_[:alnum:]])_([^_]+?[[:alnum:]&quot;'\.\?\&amp;;:&lt;&gt;])_#&lt;${tag}&gt;$1&lt;/${tag}&gt;#gs;
    }
    elsif (length($delim) eq 1)    # one-character, general
    {
        if (${$line_ref} =~ m/\B[${delim}]([[:alpha:]])[${delim}]\B/s)
        {
            ${$line_ref} =~ s/\B[${delim}]([[:alpha:]])[${delim}]\B/&lt;${tag}&gt;$1&lt;\/${tag}&gt;/gs;
        }
        ${$line_ref} =~
            s#(?&lt;![${delim}])[${delim}]([^${delim}]+?[[:alnum:]&quot;'\.\?\&amp;;:&lt;&gt;])[${delim}]#&lt;${tag}&gt;$1&lt;/${tag}&gt;#gs;
    }
    else
    {
        ${$line_ref} =~
s/(?&lt;!${delim})${delim}((\w|[&quot;'])(\w|[-\s\.;:,!?&quot;'])*[^\s])${delim}/&lt;${tag}&gt;$1&lt;\/${tag}&gt;/gs;
        ${$line_ref} =~ s/${delim}]([[:alpha:]])${delim}/&lt;${tag}&gt;$1&lt;\/${tag}&gt;/gs;
    }
}    # do_delim</pre>
<p>
</p>
<h2><a name="glob2regexp">glob2regexp</a></h2>
<pre>
    $regexp = glob2regexp($glob);</pre>
<p>Convert very simple globs to regexps
=cut
sub glob2regexp
{
    my ($glob) = @_;</p>
<pre>
    # Escape funky chars
    $glob =~ s/[^\w\[\]\*\?\|\\]/\\$&amp;/g;
    my ($regexp, $i, $len, $escaped) = (&quot;&quot;, 0, length($glob), 0);</pre>
<pre>
    for (; $i &lt; $len; $i++)
    {
        my $char = substr($glob, $i, 1);
        if ($escaped)
        {
            $escaped = 0;
            $regexp .= $char;
            next;
        }
        if ($char eq &quot;\\&quot;)
        {
            $escaped = 1;
            next;
            $regexp .= $char;
        }
        if ($char eq &quot;?&quot;)
        {
            $regexp .= &quot;.&quot;;
            next;
        }
        if ($char eq &quot;*&quot;)
        {
            $regexp .= &quot;.*&quot;;
            next;
        }
        $regexp .= $char;    # Normal character
    }
    join('', &quot;\\b&quot;, $regexp, &quot;\\b&quot;);
}    # glob2regexp</pre>
<p>
</p>
<h2><a name="add_regexp_to_links_table">add_regexp_to_links_table</a></h2>
<pre>
    $self-&gt;add_regexp_to_links_table(label=&gt;$label,
                                     pattern=&gt;$pattern,
                                     url=&gt;$url,
                                     switches=&gt;$switches);</pre>
<p>Add the given regexp ``link definition'' to the links table.
=cut
sub add_regexp_to_links_table ($%)
{
    my $self = shift;
    my %args = (
        label =&gt; undef,
        pattern =&gt; undef,
        url =&gt; undef,
        switches =&gt; undef,
        @_
    );
    my $label = $args{label};
    my $pattern = $args{pattern};
    my $URL = $args{url};
    my $switches = $args{switches};</p>
<pre>
    # No sense adding a second one if it's already in there.
    # It would never get used.
    if (!$self-&gt;{__links_table}-&gt;{$label})
    {</pre>
<pre>
        # Keep track of the order they were added so we can
        # look for matches in the same order
        push(@{$self-&gt;{__links_table_order}}, ($label));</pre>
<pre>
        $self-&gt;{__links_table_patterns}-&gt;{$label} = $pattern;
        $self-&gt;{__links_table}-&gt;{$label}        = $URL;      # Put it in The Table
        $self-&gt;{__links_switch_table}-&gt;{$label} = $switches;
        my $ind = @{$self-&gt;{__links_table_order}} - 1;
        print STDERR &quot; (&quot;, $ind,
          &quot;)\tLABEL: $label \tPATTERN: $pattern\n\tVALUE: $URL\n\tSWITCHES: $switches\n\n&quot;
          if ($self-&gt;{dict_debug} &amp; 1);
    }
    else
    {
        if ($self-&gt;{dict_debug} &amp; 1)
        {
            print STDERR &quot; Skipping entry.  Key already in table.\n&quot;;
            print STDERR &quot;\tLABEL: $label \tPATTERN: $pattern\n\tVALUE: $URL\n\n&quot;;
        }
    }
}    # add_regexp_to_links_table</pre>
<p>
</p>
<h2><a name="add_literal_to_links_table">add_literal_to_links_table</a></h2>
<pre>
    $self-&gt;add_literal_to_links_table(label=&gt;$label,
                                      pattern=&gt;$pattern,
                                      url=&gt;$url,
                                      switches=&gt;$switches);</pre>
<p>Add the given literal ``link definition'' to the links table.
=cut
sub add_literal_to_links_table ($%)
{
    my $self = shift;
    my %args = (
        label =&gt; undef,
        pattern =&gt; undef,
        url =&gt; undef,
        switches =&gt; undef,
        @_
    );
    my $label = $args{label};
    my $pattern = $args{pattern};
    my $URL = $args{url};
    my $switches = $args{switches};</p>
<pre>
    $pattern =~ s/(\W)/\\$1/g;    # Escape non-alphanumeric chars
    $pattern = &quot;\\b$pattern\\b&quot;;      # Make a regexp out of it
    $self-&gt;add_regexp_to_links_table(label=&gt;$label, pattern=&gt;$pattern, url=&gt;$URL, switches=&gt;$switches);
}    # add_literal_to_links_table</pre>
<p>
</p>
<h2><a name="add_glob_to_links_table">add_glob_to_links_table</a></h2>
<pre>
    $self-&gt;add_glob_to_links_table(label=&gt;$label,
                                   pattern=&gt;$pattern,
                                   url=&gt;$url,
                                   switches=&gt;$switches);</pre>
<p>Add the given glob ``link definition'' to the links table.
=cut
sub add_glob_to_links_table ($%)
{
    my $self = shift;
    my %args = (
        label =&gt; undef,
        pattern =&gt; undef,
        url =&gt; undef,
        switches =&gt; undef,
        @_
    );
    my $label = $args{label};
    my $pattern = $args{pattern};
    my $URL = $args{url};
    my $switches = $args{switches};</p>
<pre>
    $self-&gt;add_regexp_to_links_table(pattern=&gt;glob2regexp($pattern),
        label=&gt;$label,
        url=&gt;$URL, switches=&gt;$switches);
}    # add_glob_to_links_table</pre>
<p>
</p>
<h2><a name="parse_dict">parse_dict</a></h2>
<pre>

    $self-&gt;parse_dict($dictfile, $dict);</pre>
<p>Parse the dictionary file.
(see also load_dictionary_links, for things that were stripped)
=cut
sub parse_dict ($$$)
{
    my $self = shift;</p>
<pre>
    my ($dictfile, $dict) = @_;</pre>
<pre>
    print STDERR &quot;Parsing dictionary file $dictfile\n&quot;
      if ($self-&gt;{dict_debug} &amp; 1);</pre>
<pre>
    if ($dict =~ /-&gt;\s*-&gt;/)
    {
        my $message = &quot;Two consecutive '-&gt;'s found in $dictfile\n&quot;;
        my $near;</pre>
<pre>
        # Print out any useful context so they can find it.
        ($near) = $dict =~ /([\S ]*\s*-&gt;\s*-&gt;\s*\S*)/;
        $message .= &quot;\n$near\n&quot; if $near =~ /\S/;
        die $message;
    }</pre>
<pre>
    my ($key, $URL, $switches, $options);
    while ($dict =~ /\s*(.+)\s+\-+([iehos]+\-+)?\&gt;\s*(.*\S+)\s*\n/ig)
    {
        $key      = $1;
        $options  = $2;
        $options  = &quot;&quot; unless defined($options);
        $URL      = $3;
        $switches = 0;
        # Case insensitivity
        $switches += $LINK_NOCASE if $options =~ /i/i;
        # Evaluate as Perl code
        $switches += $LINK_EVAL if $options =~ /e/i;
        # provides HTML, not just URL
        $switches += $LINK_HTML if $options =~ /h/i;
        # Only do this link once
        $switches += $LINK_ONCE if $options =~ /o/i;
        # Only do this link once per section
        $switches += $LINK_SECT_ONCE if $options =~ /s/i;</pre>
<pre>
        $key =~ s/\s*$//;    # Chop trailing whitespace</pre>
<pre>
        if ($key =~ m|^/|)   # Regexp
        {
            $key = substr($key, 1);
            $key =~ s|/$||;    # Allow them to forget the closing /
            $self-&gt;add_regexp_to_links_table(pattern=&gt;$key, label=&gt;$key, url=&gt;$URL, switches=&gt;$switches);
        }
        elsif ($key =~ /^\|/)    # alternate regexp format
        {
            $key = substr($key, 1);
            $key =~ s/\|$//;      # Allow them to forget the closing |
            $key =~ s|/|\\/|g;    # Escape all slashes
            $self-&gt;add_regexp_to_links_table(pattern=&gt;$key, label=&gt;$key, url=&gt;$URL, switches=&gt;$switches);
        }
        elsif ($key =~ /\&quot;/)
        {
            $key = substr($key, 1);
            $key =~ s/\&quot;$//;      # Allow them to forget the closing &quot;
            $self-&gt;add_literal_to_links_table(pattern=&gt;$key, label=&gt;$key, url=&gt;$URL, switches=&gt;$switches);
        }
        else
        {
            $self-&gt;add_glob_to_links_table(pattern=&gt;$key, label=&gt;$key, url=&gt;$URL, switches=&gt;$switches);
        }
    }</pre>
<p>}    # parse_dict</p>
<p>
</p>
<h2><a name="setup_dict_checking">setup_dict_checking</a></h2>
<pre>
    $self-&gt;setup_dict_checking();</pre>
<p>Set up the dictionary checking.
=cut
sub setup_dict_checking ($)
{
    my $self = shift;</p>
<pre>
    # now create the replace funcs and precomile the regexes
    my ($URL, $switches, $pattern, $options, $tag1, $tag2);
    my ($href, $r_sw);
    my @subs;
    my $i = 0;
    foreach my $label (@{$self-&gt;{__links_table_order}})
    {
        $switches = $self-&gt;{__links_switch_table}-&gt;{$label};
        $pattern = $self-&gt;{__links_table_patterns}-&gt;{$label};</pre>
<pre>
        $href = $self-&gt;{__links_table}-&gt;{$label};</pre>
<pre>
        if (!($switches &amp; $LINK_HTML))
        {
            $href =~ s#/#\\/#g;
            $href = (
                $self-&gt;{lower_case_tags}
                ? join('', '&lt;a href=&quot;', $href, '&quot;&gt;$&amp;&lt;\\/a&gt;')
                : join('', '&lt;A HREF=&quot;', $href, '&quot;&gt;$&amp;&lt;\\/A&gt;')
            );
        }
        else
        {
            # change the uppercase tags to lower case
            if ($self-&gt;{lower_case_tags})
            {
                $href =~ s#(&lt;/)([A-Z]*)(&gt;)#${1}\L${2}${3}#g;
                $href =~ s/(&lt;)([A-Z]*)(&gt;)/${1}\L${2}${3}/g;
                # and the anchors
                $href =~ s/(&lt;)(A\s*HREF)([^&gt;]*&gt;)/$1\L$2$3/g;
            }
            $href =~ s#/#\\/#g;
        }</pre>
<pre>
        $r_sw = &quot;s&quot;;    # Options for replacing
        $r_sw .= &quot;i&quot; if ($switches &amp; $LINK_NOCASE);
        $r_sw .= &quot;e&quot; if ($switches &amp; $LINK_EVAL);</pre>
<pre>
        # Generate code for replacements.
        # Create an anonymous subroutine for each replacement,
        # and store its reference in an array.
        # We need to do an &quot;eval&quot; to create these because we need to
        # be able to treat the *contents* of the $href variable
        # as if it were perl code, because sometimes the $href
        # contains things which need to be evaluated, such as $&amp; or $1,
        # not just those cases where we have a &quot;e&quot; switch.
        my $code = &lt;&lt;EOT;
\$self-&gt;{__repl_code}-&gt;[$i] =
sub {
my \$al = shift;
\$al =~ s/$pattern/$href/$r_sw;
return \$al;
};
EOT
        print STDERR $code if ($self-&gt;{dict_debug} &amp; 2);
        push @subs, $code;</pre>
<pre>
        # compile searching pattern
        if ($switches &amp; $LINK_NOCASE)    # i
        {
            $self-&gt;{__search_patterns}-&gt;[$i] = qr/$pattern/si;
        }
        else
        {
            $self-&gt;{__search_patterns}-&gt;[$i] = qr/$pattern/s;
        }
        $i++;
    }
    # now eval the replacements code string
    my $codes = join('', @subs);
    eval &quot;$codes&quot;;
}    # setup_dict_checking</pre>
<p>
</p>
<h2><a name="in_link_context">in_link_context</a></h2>
<pre>
    if ($self-&gt;in_link_context($match, $before))
    {
        ...
    }</pre>
<p>Check if we are inside a link (&lt;a ...&gt;); certain kinds of substitution are
not allowed here.</p>
<p>
</p>
<h2><a name="apply_links">apply_links</a></h2>
<pre>
    $self-&gt;apply_links(para_ref=&gt;$para_ref,
                       para_action_ref=&gt;$para_action_ref);</pre>
<p>Apply links and formatting to this paragraph.
=cut
sub apply_links ($%)
{
    my $self = shift;
    my %args = (
        para_ref        =&gt; undef,
        para_action_ref =&gt; undef,
        @_
    );
    my $para_ref        = $args{para_ref};
    my $para_action_ref = $args{para_action_ref};</p>
<pre>
    if ($self-&gt;{make_links}
        &amp;&amp; @{$self-&gt;{__links_table_order}})
    {
        $self-&gt;check_dictionary_links(
            line_ref        =&gt; $para_ref,
            line_action_ref =&gt; $para_action_ref
        );
    }
    if ($self-&gt;{bold_delimiter})
    {
        my $tag = ($self-&gt;{lower_case_tags} ? 'strong' : 'STRONG');
        $self-&gt;do_delim(
            line_ref        =&gt; $para_ref,
            line_action_ref =&gt; $para_action_ref,
            delim           =&gt; $self-&gt;{bold_delimiter},
            tag             =&gt; $tag
        );
    }
    if ($self-&gt;{italic_delimiter})
    {
        my $tag = ($self-&gt;{lower_case_tags} ? 'em' : 'EM');
        $self-&gt;do_delim(
            line_ref        =&gt; $para_ref,
            line_action_ref =&gt; $para_action_ref,
            delim           =&gt; $self-&gt;{italic_delimiter},
            tag             =&gt; $tag
        );
    }
    if ($self-&gt;{underline_delimiter})
    {
        my $tag = ($self-&gt;{lower_case_tags} ? 'u' : 'U');
        $self-&gt;do_delim(
            line_ref        =&gt; $para_ref,
            line_action_ref =&gt; $para_action_ref,
            delim           =&gt; $self-&gt;{underline_delimiter},
            tag             =&gt; $tag
        );
    }</pre>
<p>}    # apply_links</p>
<p>
</p>
<h2><a name="check_dictionary_links">check_dictionary_links</a></h2>
<pre>
    $self-&gt;check_dictionary_links(line_ref=&gt;$line_ref,
                                  line_action_ref=&gt;$line_action_ref);</pre>
<p>Check (and alter if need be) the bits in this line matching
the patterns in the link dictionary.
=cut
sub check_dictionary_links ($%)
{
    my $self = shift;
    my %args = (
        line_ref        =&gt; undef,
        line_action_ref =&gt; undef,
        @_
    );
    my $line_ref        = $args{line_ref};
    my $line_action_ref = $args{line_action_ref};</p>
<pre>
    my ($switches, $pattern, $options, $repl_func);
    my ($linkme, $line_with_links);</pre>
<pre>
    # for each pattern, check and alter the line
    my $i = 0;
    foreach my $label (@{$self-&gt;{__links_table_order}})
    {
        $switches = $self-&gt;{__links_switch_table}-&gt;{$label};
        $pattern = $self-&gt;{__links_table_patterns}-&gt;{$label};</pre>
<pre>
        # check the pattern
        if ($switches &amp; $LINK_ONCE)    # Do link only once
        {
            $line_with_links = '';
            if (!$self-&gt;{__done_with_link}-&gt;[$i]
                &amp;&amp; ${$line_ref} =~ $self-&gt;{__search_patterns}-&gt;[$i])
            {
                $self-&gt;{__done_with_link}-&gt;[$i] = 1;
                $line_with_links .= $`;
                $linkme = $&amp;;</pre>
<pre>
                ${$line_ref} = $';
                if (!$self-&gt;in_link_context($linkme, $line_with_links))
                {
                    print STDERR &quot;Link rule $i matches $linkme\n&quot;
                      if ($self-&gt;{dict_debug} &amp; 4);</pre>
<pre>
                    # call the special subroutine already created to do
                    # this replacement
                    $repl_func = $self-&gt;{__repl_code}-&gt;[$i];
                    $linkme    = &amp;$repl_func($linkme);
                }
                $line_with_links .= $linkme;
            }
            ${$line_ref} = $line_with_links . ${$line_ref};
        }
        elsif ($switches &amp; $LINK_SECT_ONCE)    # Do link only once per section
        {
            $line_with_links = '';
            if (!$self-&gt;{__done_with_sect_link}-&gt;[$i]
                &amp;&amp; ${$line_ref} =~ $self-&gt;{__search_patterns}-&gt;[$i])
            {
                $self-&gt;{__done_with_sect_link}-&gt;[$i] = 1;
                $line_with_links .= $`;
                $linkme = $&amp;;</pre>
<pre>
                ${$line_ref} = $';
                if (!$self-&gt;in_link_context($linkme, $line_with_links))
                {
                    print STDERR &quot;Link rule $i matches $linkme\n&quot;
                      if ($self-&gt;{dict_debug} &amp; 4);</pre>
<pre>
                    # call the special subroutine already created to do
                    # this replacement
                    $repl_func = $self-&gt;{__repl_code}-&gt;[$i];
                    $linkme    = &amp;$repl_func($linkme);
                }
                $line_with_links .= $linkme;
            }
            ${$line_ref} = $line_with_links . ${$line_ref};
        }
        else
        {
            $line_with_links = '';
            while (${$line_ref} =~ $self-&gt;{__search_patterns}-&gt;[$i])
            {
                $line_with_links .= $`;
                $linkme = $&amp;;</pre>
<pre>
                ${$line_ref} = $';
                if (!$self-&gt;in_link_context($linkme, $line_with_links))
                {
                    print STDERR &quot;Link rule $i matches $linkme\n&quot;
                      if ($self-&gt;{dict_debug} &amp; 4);</pre>
<pre>
                    # call the special subroutine already created to do
                    # this replacement
                    $repl_func = $self-&gt;{__repl_code}-&gt;[$i];
                    $linkme    = &amp;$repl_func($linkme);
                }
                $line_with_links .= $linkme;
            }
            ${$line_ref} = $line_with_links . ${$line_ref};
        }
        $i++;
    }
    ${$line_action_ref} |= $LINK;
}    # check_dictionary_links</pre>
<p>
</p>
<h2><a name="load_dictionary_links">load_dictionary_links</a></h2>
<pre>
    $self-&gt;load_dictionary_links();</pre>
<p>Load the dictionary links.
=cut
sub load_dictionary_links ($)
{
    my $self = shift;</p>
<pre>
    @{$self-&gt;{__links_table_order}} = ();
    %{$self-&gt;{__links_table}}       = ();</pre>
<pre>
    my $dict;
    foreach $dict (@{$self-&gt;{links_dictionaries}})
    {
        next unless $dict;
        open(DICT, &quot;$dict&quot;) || die &quot;Can't open Dictionary file $dict\n&quot;;</pre>
<pre>
        my @lines = ();
        while (&lt;DICT&gt;)
        {
            # skip lines that start with '#'
            next if /^\#/;
            # skip lines that end with unescaped ':'
            next if /^.*[^\\]:\s*$/;
            push @lines, $_;
        }
        close(DICT);
        my $contents = join('', @lines);
        $self-&gt;parse_dict($dict, $contents);
    }
    # last of all, do the system dictionary, already read in from DATA
    if ($self-&gt;{__global_links_data})
    {
        $self-&gt;parse_dict(&quot;DATA&quot;, $self-&gt;{__global_links_data});
    }</pre>
<pre>
    $self-&gt;setup_dict_checking();
}    # load_dictionary_links</pre>
<p>
</p>
<h2><a name="do_file_start">do_file_start</a></h2>
<pre>
    $self-&gt;do_file_start($outhandle, $para);</pre>
<p>Extra stuff needed for the beginning:
HTML headers, and prepending a file if desired.
=cut
sub do_file_start ($$$)
{
    my $self      = shift;
    my $outhandle = shift;
    my $para      = shift;</p>
<pre>
    if (!$self-&gt;{extract})
    {
        my @para_lines = split(/\n/, $para);
        my $first_line = $para_lines[0];</pre>
<pre>
        if ($self-&gt;{doctype})
        {
            if ($self-&gt;{xhtml})
            {
                print $outhandle
'&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;',
                  &quot;\n&quot;;
                print $outhandle
                  '&quot;<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd</a>&quot;&gt;',
                  &quot;\n&quot;;
                print $outhandle $self-&gt;get_tag('HTML',
                    inside_tag =&gt; ' xmlns=&quot;<a href="http://www.w3.org/1999/xhtml&quot">http://www.w3.org/1999/xhtml&quot</a>;'), &quot;\n&quot;;
            }
            else
            {
                print $outhandle '&lt;!DOCTYPE HTML PUBLIC &quot;', $self-&gt;{doctype},
                  &quot;\&quot;&gt;\n&quot;;
                print $outhandle $self-&gt;get_tag('HTML'), &quot;\n&quot;;
            }
        }
        print $outhandle $self-&gt;get_tag('HEAD'), &quot;\n&quot;;</pre>
<pre>
        # if --titlefirst is set and --title isn't, use the first line
        # as the title.
        if ($self-&gt;{titlefirst} &amp;&amp; !$self-&gt;{title})
        {
            my ($tit) = $first_line =~ /^ *(.*)/;    # grab first line
            $tit =~ s/ *$//;                         # strip trailing whitespace
            $tit = escape($tit) if $self-&gt;{escape_HTML_chars};
            $self-&gt;{'title'} = $tit;
        }
        if (!$self-&gt;{title})
        {
            $self-&gt;{'title'} = &quot;&quot;;
        }
        print $outhandle $self-&gt;get_tag('TITLE'), $self-&gt;{title},
          $self-&gt;close_tag('TITLE'), &quot;\n&quot;;</pre>
<pre>
        if ($self-&gt;{append_head})
        {
            open(APPEND, $self-&gt;{append_head})
              || die &quot;Failed to open &quot;, $self-&gt;{append_head}, &quot;\n&quot;;
            while (&lt;APPEND&gt;)
            {
                print $outhandle $_;
            }
            close(APPEND);
        }</pre>
<pre>
        if ($self-&gt;{lower_case_tags})
        {
            print $outhandle $self-&gt;get_tag(
                'META',
                tag_type   =&gt; 'empty',
                inside_tag =&gt; &quot; name=\&quot;generator\&quot; content=\&quot;$PROG v$VERSION\&quot;&quot;
              ),
              &quot;\n&quot;;
        }
        else
        {
            print $outhandle $self-&gt;get_tag(
                'META',
                tag_type   =&gt; 'empty',
                inside_tag =&gt; &quot; NAME=\&quot;generator\&quot; CONTENT=\&quot;$PROG v$VERSION\&quot;&quot;
              ),
              &quot;\n&quot;;
        }
        if ($self-&gt;{style_url})
        {
            my $style_url = $self-&gt;{style_url};
            if ($self-&gt;{lower_case_tags})
            {
                print $outhandle $self-&gt;get_tag(
                    'LINK',
                    tag_type   =&gt; 'empty',
                    inside_tag =&gt;
&quot; rel=\&quot;stylesheet\&quot; type=\&quot;text/css\&quot; href=\&quot;$style_url\&quot;&quot;
                  ),
                  &quot;\n&quot;;
            }
            else
            {
                print $outhandle $self-&gt;get_tag(
                    'LINK',
                    tag_type   =&gt; 'empty',
                    inside_tag =&gt;
&quot; REL=\&quot;stylesheet\&quot; TYPE=\&quot;text/css\&quot; HREF=\&quot;$style_url\&quot;&quot;
                  ),
                  &quot;\n&quot;;
            }
        }
        print $outhandle $self-&gt;close_tag('HEAD'), &quot;\n&quot;;
        if ($self-&gt;{body_deco})
        {
            print $outhandle $self-&gt;get_tag('BODY',
                inside_tag =&gt; $self-&gt;{body_deco}), &quot;\n&quot;;
        }
        else
        {
            print $outhandle $self-&gt;get_tag('BODY'), &quot;\n&quot;;
        }
    }</pre>
<pre>
    if ($self-&gt;{prepend_file})
    {
        if (-r $self-&gt;{prepend_file})
        {
            open(PREPEND, $self-&gt;{prepend_file});
            while (&lt;PREPEND&gt;)
            {
                print $outhandle $_;
            }
            close(PREPEND);
        }
        else
        {
            print STDERR &quot;Can't find or read file &quot;, $self-&gt;{prepend_file},
              &quot; to prepend.\n&quot;;
        }
    }
}    # do_file_start</pre>
<p>
</p>
<h2><a name="do_init_call">do_init_call</a></h2>
<pre>
    $self-&gt;do_init_call();</pre>
<p>Certain things, like reading link dictionaries, need to be done only
once.</p>
<p>
</p>
<hr />
<h1><a name="file_formats">FILE FORMATS</a></h1>
<p>There are two files which are used which can affect the outcome of the
conversion.  One is the link dictionary, which contains patterns (of how
to recognise http links and other things) and how to convert them. The
other is, naturally, the format of the input file itself.</p>
<p>
</p>
<h2><a name="link_dictionary">Link Dictionary</a></h2>
<p>A link dictionary file contains patterns to match, and what to convert
them to.  It is called a ``link'' dictionary because it was intended to be
something which defined what a href link was, but it can be used for
more than that.  However, if you wish to define your own links, it is
strongly advised to read up on regular expressions (regexes) because
this relies heavily on them.</p>
<p>The file consists of comments (which are lines starting with #)
and blank lines, and link entries.
Each entry consists of a regular expression, a -&gt; separator (with
optional flags), and a link ``result''.</p>
<p>In the simplest case, with no flags, the regular expression
defines the pattern to look for, and the result says what part
of the regular expression is the actual link, and the link which
is generated has the href as the link, and the whole matched pattern
as the visible part of the link.  The first character of the regular
expression is taken to be the separator for the regex, so one
could either use the traditional / separator, or something else
such as | (which can be helpful with URLs which are full of / characters).</p>
<p>So, for example, an ftp URL might be defined as:</p>
<pre>
    |ftp:[\w/\.:+\-]+|      -&gt; $&amp;</pre>
<p>This takes the whole pattern as the href, and the resultant link
has the same thing in the href as in the contents of the anchor.</p>
<p>But sometimes the href isn't the whole pattern.</p>
<pre>
    /&amp;lt;URL:\s*(\S+?)\s*&amp;gt;/ --&gt; $1</pre>
<p>With the above regex, a () grouping marks the first subexpression,
which is represented as $1 (rather than $&amp; the whole expression).
This entry matches a URL which was marked explicity as a URL
with the pattern &lt;URL:foo&gt;  (note the &amp;lt; is shown as the
entity, not the actual character.  This is because by the
time the links dictionary is checked, all such things have
already been converted to their HTML entity forms, unless, of course,
the escape_HTML_chars option was turned off)
This would give us a link in the form
&lt;A HREF=``foo''&gt;&amp;lt;URL:foo&amp;gt;&lt;/A&gt;</p>
<p><strong>The h flag</strong></p>
<p>However, if we want more control over the way the link is constructed,
we can construct it ourself.  If one gives the h flag, then the
``result'' part of the entry is taken not to contain the href part of
the link, but the whole link.</p>
<p>For example, the entry:</p>
<pre>
    /&amp;lt;URL:\s*(\S+?)\s*&amp;gt;/ -h-&gt; &lt;A HREF=&quot;$1&quot;&gt;$1&lt;/A&gt;</pre>
<p>will take &lt;URL:foo&gt; and give us &lt;A HREF=``foo''&gt;foo&lt;/A&gt;</p>
<p>However, this is a very powerful mechanism, because it
can be used to construct custom tags which aren't links at all.
For example, to flag *italicised words* the following
entry will surround the words with EM tags.</p>
<pre>
    /\B\*([a-z][a-z -]*[a-z])\*\B/ -hi-&gt; &lt;EM&gt;$1&lt;/EM&gt;</pre>
<p><strong>The i flag</strong></p>
<p>This turns on ignore case in the pattern matching.</p>
<p><strong>The e flag</strong></p>
<p>This turns on execute in the pattern substitution.  This really
only makes sense if h is turned on too.  In that case, the ``result''
part of the entry is taken as perl code to be executed, and the
result of that code is what replaces the pattern.</p>
<p><strong>The o flag</strong></p>
<p>This marks the entry as a once-only link.  This will convert the
first instance of a matching pattern, and ignore any others
further on.</p>
<p>For example, the following pattern will take the first mention
of HTML::TextToHTML and convert it to a link to the module's home page.</p>
<pre>
    &quot;HTML::TextToHTML&quot;  -io-&gt; <a href="http://www.katspace.com/tools/text_to_html/">http://www.katspace.com/tools/text_to_html/</a></pre>
<p>
</p>
<h2><a name="input_file_format">Input File Format</a></h2>
<p>For the most part, this module tries to use intuitive conventions for
determining the structure of the text input.  Unordered lists are
marked by bullets; ordered lists are marked by numbers or letters;
in either case, an increase in indentation marks a sub-list contained
in the outer list.</p>
<p>Headers (apart from custom headers) are distinguished by ``underlines''
underneath them; headers in all-capitals are distinguished from
those in mixed case.  All headers, both normal and custom headers,
are expected to start at the first line in a ``paragraph''.</p>
<p>In other words, the following is a header:</p>
<pre>
    I am Head Man
    -------------</pre>
<p>But the following does not have a header:</p>
<pre>
    I am not a head Man, man
    I am Head Man
    -------------</pre>
<p>Tables require a more rigid convention.  A table must be marked as a
separate paragraph, that is, it must be surrounded by blank lines.
Tables come in different types.  For a table to be parsed, its
--table_type option must be on, and the --make_tables option must be true.</p>
<p><strong>ALIGN Table Type</strong></p>
<p>Columns must be separated by two or more spaces (this prevents
accidental incorrect recognition of a paragraph where interword spaces
happen to line up).  If there are two or more rows in a paragraph and
all rows share the same set of (two or more) columns, the paragraph is
assumed to be a table.  For example</p>
<pre>
    -e  File exists.
    -z  File has zero size.
    -s  File has nonzero size (returns size).</pre>
<p>becomes</p>
<pre>
    &lt;TABLE&gt;
    &lt;TR&gt;&lt;TD&gt;-e&lt;/TD&gt;&lt;TD&gt;File exists.&lt;/TD&gt;&lt;/TR&gt;
    &lt;TR&gt;&lt;TD&gt;-z&lt;/TD&gt;&lt;TD&gt;File has zero size.&lt;/TD&gt;&lt;/TR&gt;
    &lt;TR&gt;&lt;TD&gt;-s&lt;/TD&gt;&lt;TD&gt;File has nonzero size (returns size).&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TABLE&gt;</pre>
<p>This guesses for each column whether it is intended to be left,
centre or right aligned.</p>
<p><strong>BORDER Table Type</strong></p>
<p>This table type has nice borders around it, and will be rendered
with a border, like so:</p>
<pre>
    +---------+---------+
    | Column1 | Column2 |
    +---------+---------+
    | val1    | val2    |
    | val3    | val3    |
    +---------+---------+</pre>
<p>The above becomes</p>
<pre>
    &lt;TABLE border=&quot;1&quot;&gt;
    &lt;THEAD&gt;&lt;TR&gt;&lt;TH&gt;Column1&lt;/TH&gt;&lt;TH&gt;Column2&lt;/TH&gt;&lt;/TR&gt;&lt;/THEAD&gt;
    &lt;TBODY&gt;
    &lt;TR&gt;&lt;TD&gt;val1&lt;/TD&gt;&lt;TD&gt;val2&lt;/TD&gt;&lt;/TR&gt;
    &lt;TR&gt;&lt;TD&gt;val3&lt;/TD&gt;&lt;TD&gt;val3&lt;/TD&gt;&lt;/TR&gt;
    &lt;/TBODY&gt;
    &lt;/TABLE&gt;</pre>
<p>It can also have an optional caption at the start.</p>
<pre>
         My Caption
    +---------+---------+
    | Column1 | Column2 |
    +---------+---------+
    | val1    | val2    |
    | val3    | val3    |
    +---------+---------+</pre>
<p><strong>PGSQL Table Type</strong></p>
<p>This format of table is what one gets from the output of a Postgresql
query.</p>
<pre>
     Column1 | Column2
    ---------+---------
     val1    | val2
     val3    | val3
    (2 rows)</pre>
<p>This can also have an optional caption at the start.
This table is also rendered with a border and table-headers like
the BORDER type.</p>
<p><strong>DELIM Table Type</strong></p>
<p>This table type is delimited by non-alphanumeric characters, and has to
have at least two rows and two columns before it's recognised as a table.</p>
<p>This one is delimited by the '| character:</p>
<pre>
    | val1  | val2  |
    | val3  | val3  |</pre>
<p>But one can use almost any suitable character such as : # $ % + and so on.
This is clever enough to figure out what you are using as the delimiter
if you have your data set up like a table.  Note that the line has to
both begin and end with the delimiter, as well as using it to separate
values.</p>
<p>This can also have an optional caption at the start.</p>
<p>
</p>
<hr />
<h1><a name="examples">EXAMPLES</a></h1>
<pre>
    use HTML::TextToHTML;
 
=head2 Create a new object</pre>
<pre>
    my $conv = new HTML::TextToHTML();</pre>
<pre>
    my $conv = new HTML::TextToHTML(title=&gt;&quot;Wonderful Things&quot;,
                            default_link_dict=&gt;$my_link_file,
      );</pre>
<p>
</p>
<h2><a name="add_further_arguments">Add further arguments</a></h2>
<pre>
    $conv-&gt;args(short_line_length=&gt;60,
               preformat_trigger_lines=&gt;4,
               caps_tag=&gt;&quot;strong&quot;,
      );</pre>
<p>
</p>
<h2><a name="convert_a_file">Convert a file</a></h2>
<pre>
    $conv-&gt;txt2html(infile=&gt;[$text_file],
                     outfile=&gt;$html_file,
                     title=&gt;&quot;Wonderful Things&quot;,
                     mail=&gt;1
      );</pre>
<p>
</p>
<h2><a name="make_a_pipleline">Make a pipleline</a></h2>
<pre>
    open(IN, &quot;ls |&quot;) or die &quot;could not open!&quot;;
    $conv-&gt;txt2html(inhandle=&gt;[\*IN],
                     outfile=&gt;'-',
      );</pre>
<p>
</p>
<hr />
<h1><a name="notes">NOTES</a></h1>
<ul>
<li>
<p>One cannot use ``CLEAR'' as a value for the cumulative arguments.</p>
</li>
<li>
<p>If the underline used to mark a header is off by more than 1, then 
that part of the text will not be picked up as a header unless you
change the value of --underline_length_tolerance and/or
--underline_offset_tolerance.  People tend to forget this.</p>
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>Tell me about them.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>perl
<a href="#txt2html">the txt2html manpage</a>.
Data::Dumper</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<pre>
    Kathryn Andersen (RUBYKAT)
    perlkat AT katspace dot com
    http//www.katspace.com/</pre>
<p>based on txt2html by Seth Golub</p>
<p>
</p>
<hr />
<h1><a name="copyright_and_licence">COPYRIGHT AND LICENCE</a></h1>
<p>Original txt2html script copyright (c) 1994-2000 Seth Golub &lt;seth AT aigeek.com&gt;

</p>
<p>Copyright (c) 2002-2005 by Kathryn Andersen

</p>
<p>This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

</p>

</body>

</html>
